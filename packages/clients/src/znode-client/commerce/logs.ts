//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as MultifrontTypes from "../../types/interface";

import { BuildEndpointQueryString, getHeaders } from "./BaseClient";

import { FilterTuple } from "../V1";

const baseUrl = process.env.API_URL;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Create Order Logs For History.
         * @param body (optional) 
         * @return OK. Indicates that the request is successfully executed, and the response body contains the requested data.
         */
    
        export async function Logs_createLog(body:MultifrontTypes.CreateLogsRequestModel | undefined): Promise<MultifrontTypes.CreateLogsResponseModel> {

        let url_ = baseUrl + "commerceapi/v1/create-log";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Logs_processCreateLog(_response);
        });
    }
   
   function Logs_processCreateLog(response: Response): Promise<MultifrontTypes.CreateLogsResponseModel> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.CreateLogsResponseModel;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("No Content. Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Bad Request. Indicates that the server could not understand the request due to invalid syntax.", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Internal Server Error. Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
        
        
            
            
            

        

        
            
            
                
            
        
    
    
    
        
    
    
    /**
         * Get Order History List Details.
         * @param filter (optional) A collection of filters to apply when retrieving the address list.
         * @param sort (optional) A sorting collection that will include the any system generated field from the response and offers both ascending (ASC) and descending (DESC) sorting choices.If the User is not applied the sorting than by default system generated ID will be considered.
         * @param pageIndex (optional) When the record count is high, utilizing pagination enables the retrieval of a specific range of records.
         * @param pageSize (optional) The number of items to be displayed per page in paginated within paginated results.
         * @return OK. Indicates that the request is successfully executed, and the response body contains the requested data.
         */
            
export async function Logs_indexByClassType(classType:string, classNumber:string, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined): Promise<MultifrontTypes.NotesDetailsResponceModel> {
    

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "{classType}/{classNumber}";
    
            
            
        
            
            
        
            
            
        
            
            
        
    
   
    
                url_ += BuildEndpointQueryString({filter, sort, pageIndex, pageSize});
    

            
            
            
            
    

        if (classType === undefined || classType === null)
            throw new Error("The parameter 'classType' must be defined.");
        url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
        if (classNumber === undefined || classNumber === null)
            throw new Error("The parameter 'classNumber' must be defined.");
        url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
                return Logs_processIndexByClassType(_response);
      
        });
    }
   
   
  function Logs_processIndexByClassType(response: Response): Promise<MultifrontTypes.NotesDetailsResponceModel> {
      const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.NotesDetailsResponceModel;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("No Content. Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Bad Request. Indicates that the server could not understand the request due to invalid syntax.", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Internal Server Error. Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
       
      
    }

    
        
        
            
            
            

        

        
            
            
                
            
        
    
    
    
        
    
    
    /**
         * Get Order History List Details.
         * @param filter (optional) A collection of filters to apply when retrieving the address list.
         * @param sort (optional) A sorting collection that will include the any system generated field from the response and offers both ascending (ASC) and descending (DESC) sorting choices.If the User is not applied the sorting than by default system generated ID will be considered.
         * @param pageIndex (optional) When the record count is high, utilizing pagination enables the retrieval of a specific range of records.
         * @param pageSize (optional) The number of items to be displayed per page in paginated within paginated results.
         * @return OK. Indicates that the request is successfully executed, and the response body contains the requested data.
         */
            
export async function Logs_logDetailsByClassType(classType:string, classNumber:string, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined): Promise<MultifrontTypes.NotesDetailsResponceModel> {
    

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "commerceapi/v1/{classType}/log-details/{classNumber}";
    
            
            
        
            
            
        
            
            
        
            
            
        
    
   
    
                url_ += BuildEndpointQueryString({filter, sort, pageIndex, pageSize});
    

            
            
            
            
    

        if (classType === undefined || classType === null)
            throw new Error("The parameter 'classType' must be defined.");
        url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
        if (classNumber === undefined || classNumber === null)
            throw new Error("The parameter 'classNumber' must be defined.");
        url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
                return Logs_processLogDetailsByClassType(_response);
      
        });
    }
   
   
  function Logs_processLogDetailsByClassType(response: Response): Promise<MultifrontTypes.NotesDetailsResponceModel> {
      const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.NotesDetailsResponceModel;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("No Content. Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Bad Request. Indicates that the server could not understand the request due to invalid syntax.", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Internal Server Error. Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
       
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
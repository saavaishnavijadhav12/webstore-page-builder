//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as MultifrontTypes from "../../types/interface";

import { BuildEndpointQueryString, getHeaders } from "./BaseClient";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Calculated order details.
 * @param orderId The unique identifier of the order for which calculation details are requested.
 * @return Success (The request is successfully executed, and the response body contains the requested data.)
 * @deprecated
 */

export async function Calculate_indexByOrderId(orderId: string): Promise<MultifrontTypes.CalculateResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "{orderId}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Calculate_processIndexByOrderId(_response);
  });
}

function Calculate_processIndexByOrderId(response: Response): Promise<MultifrontTypes.CalculateResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CalculateResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Apply discount details.
 * @param cartNumber The unique identifier of apply discount.
 * @param expand (optional) The parameter 'Expand' determines calculation details are requested.
 * @param body (optional) The request DiscountRequestModel model containing details for apply discount.
 * @return OK
 */

export async function Calculate_applyDiscount(
  cartNumber: string,
  expand: string[] | undefined,
  body: MultifrontTypes.DiscountRequestModel | undefined
): Promise<MultifrontTypes.DiscountedDetailsResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/calculate/apply-discount/{cartNumber}";

  url_ += BuildEndpointQueryString({ expand });

  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Calculate_processApplyDiscount(_response);
  });
}

function Calculate_processApplyDiscount(response: Response): Promise<MultifrontTypes.DiscountedDetailsResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DiscountedDetailsResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DiscountedDetailsResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Remove discount details.
 * @param cartNumber The unique identifier of apply discount.
 * @param expand (optional) The parameter 'Expand' determines calculation details are requested.
 * @param body (optional) The request DiscountRequestModel model containing details for apply discount.
 * @return OK
 */

export async function Calculate_removeDiscountByCartNumber(cartNumber: string, expand: string[] | undefined, body: MultifrontTypes.DiscountRequestModel | undefined): Promise<any> {
  let url_ = baseUrl + "commerceapi/v1/calculate/remove-discount/{cartNumber}";

  url_ += BuildEndpointQueryString({ expand });

  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "DELETE",
    cache: "no-store",
    headers: await getHeaders("DELETE", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Calculate_processRemoveDiscountByCartNumber(_response);
  });
}

function Calculate_processRemoveDiscountByCartNumber(response: Response): Promise<MultifrontTypes.DiscountedDetailsResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DiscountedDetailsResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DiscountedDetailsResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

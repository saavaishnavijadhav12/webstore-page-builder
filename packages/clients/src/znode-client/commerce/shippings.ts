//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as MultifrontTypes from "../../types/interface";

import { getHeaders } from "./BaseClient";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Updates an order shipment.
         * @param body (optional) The data used to update the order shipment.
         * @return OK
         */
    
        export async function Shippings_orderShipment(body:MultifrontTypes.UpdateOrderShipmentRequestModel | undefined): Promise<MultifrontTypes.ShipmentResponseModel> {

        let url_ = baseUrl + "commerceapi/v1/shippings/order-shipment";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Shippings_processOrderShipment(_response);
        });
    }
   
   function Shippings_processOrderShipment(response: Response): Promise<MultifrontTypes.ShipmentResponseModel> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ShipmentResponseModel;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ShipmentResponseModel;
        return result201;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Internal Server Error ( Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
        
        
            
            
            

        

        
            
            
                
            
        
    
    
    
        
    
    
    /**
         * Removes a shipping item based on the specified class number.
         * @param classNumber The class number of the shipping item to be removed.
         * @return OK
         */
            
export async function Shippings_removeShippingByClassNumber(classNumber:string): Promise<MultifrontTypes.RemoveShippingResponseModel> {
    

        let url_ = baseUrl + "commerceapi/v1/shippings/remove-shipping/{classNumber}";

        if (classNumber === undefined || classNumber === null)
            throw new Error("The parameter 'classNumber' must be defined.");
        url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "DELETE",
            cache: "no-store",
            headers: await getHeaders("DELETE", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
           
                return Shippings_processRemoveShippingByClassNumber(_response);
      
        });
    }
   
   
  function Shippings_processRemoveShippingByClassNumber(response: Response): Promise<MultifrontTypes.RemoveShippingResponseModel> {
      const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.RemoveShippingResponseModel;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Bad Request", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
       
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
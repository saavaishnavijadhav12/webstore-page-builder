//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as MultifrontTypes from "../../types/interface";

import { BuildEndpointQueryString, getHeaders } from "./BaseClient";

import { FilterTuple } from "../V1";

const baseUrl = process.env.API_URL;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * get list of class's items.
 * @param classNumber The unique identifier of the order template items list.
 * @return Ok (The request is successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_itemListByClassType(classType: string, classNumber: string): Promise<MultifrontTypes.ClassItemListResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/item-list/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processItemListByClassType(_response);
  });
}

function CommerceCollections_processItemListByClassType(response: Response): Promise<MultifrontTypes.ClassItemListResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ClassItemListResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (An error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * List of class details.
 * @param filter (optional) A collection of filters to apply when retrieving the address list.
 * @param sort (optional) A sorting collection that will include the any system generated field from the response and offers both ascending (ASC) and descending (DESC) sorting choices.If the User is not applied the sorting than by default system generated ID will be considered.
 * @param pageIndex (optional) When the record count is high, utilizing pagination enables the retrieval of a specific range of records.
 * @param pageSize (optional) The number of items to be displayed per page in paginated within paginated results.
 * @return OK. Indicates that the request is successfully executed, and the response body contains the requested data.
 */

export async function CommerceCollections_listByClassType(
  classType: string,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.CollectionResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/list/";

  url_ += BuildEndpointQueryString({ filter, sort, pageIndex, pageSize });

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processListByClassType(_response);
  });
}

function CommerceCollections_processListByClassType(response: Response): Promise<MultifrontTypes.CollectionResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CollectionResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content. Indicates that the request is successfully executed, but the response body does not contain any data.",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request. Indicates that the server could not understand the request due to invalid syntax.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error. Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * class details based on class number
 * @param classNumber The unique identifier of the class for which class details retrieved.
 * @return OK(Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function CommerceCollections_classDetailsByClassType(classType: string, classNumber: string): Promise<MultifrontTypes.CommerceCollectionClassDetailResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/class-details/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");
  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processClassDetailsByClassType(_response);
  });
}

function CommerceCollections_processClassDetailsByClassType(response: Response): Promise<MultifrontTypes.CommerceCollectionClassDetailResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CommerceCollectionClassDetailResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Convert class to another class by providing class number and target class code.
 * @param classNumber The unique identifier of the class.
 * @param targetClassType The unique identifier of the class code.
 * @param body (optional) The ConvertClassRequestModel containing the convert class information.
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_convert(
  classType: string,
  classNumber: string,
  targetClassType: string,
  body: MultifrontTypes.ConvertClassRequestModel | undefined
): Promise<MultifrontTypes.ConvertedClassResponseMode> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/convert/{classNumber}/{targetClassType}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (targetClassType === undefined || targetClassType === null) throw new Error("The parameter 'targetClassType' must be defined.");
  url_ = url_.replace("{targetClassType}", encodeURIComponent("" + targetClassType));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processConvert(_response);
  });
}

function CommerceCollections_processConvert(response: Response): Promise<MultifrontTypes.ConvertedClassResponseMode> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ConvertedClassResponseMode);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Copy an Class to a cart for the given user.
 * @param classNumber The unique identifier of class.
 * @param targetClassType (optional) The optional unique identifier of class.
 * @param origin (optional) The optional unique identifier of class.
 * @return OK
 */

export async function CommerceCollections_copy(
  classType: string,
  classNumber: string,
  targetClassType: string | undefined,
  origin: string | undefined
): Promise<MultifrontTypes.CopiedClassResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/copy/{classNumber}";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "targetClassType=" + encodeURIComponent("" + targetClassType);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "origin=" + encodeURIComponent("" + origin);

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (targetClassType === null) throw new Error("The parameter 'targetClassType' cannot be null.");
  if (origin === null) throw new Error("The parameter 'origin' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processCopy(_response);
  });
}

function CommerceCollections_processCopy(response: Response): Promise<MultifrontTypes.CopiedClassResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CopiedClassResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CopiedClassResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates all details of class and returns a response model indicating the update status.
 * @param body (optional) The UpdateAllClassDetailRequestModel containing the updated class information.
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_updateAllDetails(
  classType: string,
  body: MultifrontTypes.UpdateAllClassDetailRequestModel | undefined
): Promise<MultifrontTypes.UpdateClassDetailsResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/update-all-details";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processUpdateAllDetails(_response);
  });
}

function CommerceCollections_processUpdateAllDetails(response: Response): Promise<MultifrontTypes.UpdateClassDetailsResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateClassDetailsResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Deletes class by the specified class numbers.
 * @param classNumbers The unique identifier of the class.
 * @return OK (Indicates that the request is successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_v1ByClassType(classType: string, classNumbers: string): Promise<MultifrontTypes.MultipleDeleteResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/{classNumbers}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumbers === undefined || classNumbers === null) throw new Error("The parameter 'classNumbers' must be defined.");
  url_ = url_.replace("{classNumbers}", encodeURIComponent("" + classNumbers));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "DELETE",
    cache: "no-store",
    headers: await getHeaders("DELETE", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processV1ByClassType(_response);
  });
}

function CommerceCollections_processV1ByClassType(response: Response): Promise<MultifrontTypes.MultipleDeleteResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.MultipleDeleteResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Deletes an item from the specified class for the given user.
 * @param classNumber The unique identifier of the class.
 * @param itemId The unique identifier of the item to be deleted from the class.
 * @return OK (Indicates that the request is successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_deleteItemByClassType(classType: string, classNumber: string, itemId: string): Promise<MultifrontTypes.DeleteResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/{classNumber}/delete-item/{itemId}";
  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (itemId === undefined || itemId === null) throw new Error("The parameter 'itemId' must be defined.");
  url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "DELETE",
    cache: "no-store",
    headers: await getHeaders("DELETE", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processDeleteItemByClassType(_response);
  });
}

function CommerceCollections_processDeleteItemByClassType(response: Response): Promise<MultifrontTypes.DeleteResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DeleteResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete all items from the specified class for the given user.
 * @param classNumber The unique identifier of the class.
 * @return OK (Indicates that the request is successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_removeAllByClassType(classType: string, classNumber: string): Promise<MultifrontTypes.DeleteResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/remove-all/{classNumber}";
  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "DELETE",
    cache: "no-store",
    headers: await getHeaders("DELETE", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processRemoveAllByClassType(_response);
  });
}

function CommerceCollections_processRemoveAllByClassType(response: Response): Promise<MultifrontTypes.DeleteResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.DeleteResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates the quantity of an item in the class and returns a response model indicating the update status.
 * @param classNumber The unique identifier of the class.
 * @param itemId The unique identifier of the class.
 * @param body (optional) The UpdateClassItemQuantityRequestMode containing the updated quantity information.
 * @return OK (Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_quantity(
  classType: string,
  classNumber: string,
  itemId: string,
  body: MultifrontTypes.UpdateClassItemQuantityRequestModel | undefined
): Promise<MultifrontTypes.UpdateItemQuantityResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/{classNumber}/quantity/{itemId}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (itemId === undefined || itemId === null) throw new Error("The parameter 'itemId' must be defined.");
  url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processQuantity(_response);
  });
}

function CommerceCollections_processQuantity(response: Response): Promise<MultifrontTypes.UpdateItemQuantityResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateItemQuantityResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request was successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates the bulk quantity of an item in the class and returns a response model indicating the update status.
 * @param classNumber The unique identifier of the class.
 * @param body (optional) The list of UpdateClassItemQuantityRequestModel containing the updated quantity information.
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_bulkQuantity(
  classType: string,
  classNumber: string,
  body: MultifrontTypes.UpdateClassItemQuantityRequestModel[] | undefined
): Promise<MultifrontTypes.UpdateBulkItemQuantityResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/bulk-quantity/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processBulkQuantity(_response);
  });
}

function CommerceCollections_processBulkQuantity(response: Response): Promise<MultifrontTypes.UpdateBulkItemQuantityResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateBulkItemQuantityResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
         * Convert an order by updating the order status, product price, and order total all details are completed.
         * @param classNumber The unique identifier of the shopping cart.
         * @param body (optional) The request ConvertToOrderRequestModel model containing details for converting cart to order.
         * @return OK (Indicates that the request was successfully executed, and the response body contains the requested data.)
         */
    
export async function CommerceCollections_placeOrder(
  classType: string,
  classNumber: string,
  body: MultifrontTypes.ConvertToOrderRequestModel | undefined
): Promise<MultifrontTypes.ConvertedToOrderResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/place-order/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processPlaceOrder(_response);
  });
}

function CommerceCollections_processPlaceOrder(response: Response): Promise<MultifrontTypes.ConvertedToOrderResponseModel> {
const status = response.status;
let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
if (status === 200) {
return response.text().then((_responseText) => {
let result200: any = null;
result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ConvertedToOrderResponseModel);
return result200;
});
} else if (status === 201) {
return response.text().then((_responseText) => {
let result201: any = null;
result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ConvertedToOrderResponseModel);
return result201;
});
} else if (status === 204) {
return response.text().then((_responseText) => {
let result204: any = null;
result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
return throwException("No Content (Indicates that the request was successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
});
} else if (status === 400) {
return response.text().then((_responseText) => {
let result400: any = null;
result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
});
} else if (status === 404) {
return response.text().then((_responseText) => {
let result404: any = null;
result404 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
});
} else if (status === 500) {
return response.text().then((_responseText) => {
let result500: any = null;
result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
});
} else if (status !== 200 && status !== 204) {
return response.text().then((_responseText) => {
return throwException("An unexpected server error occurred.", status, _responseText, _headers);
});
}
return Promise.resolve<any>(null as any);

}


/**
 * get class id by class number for using a cached source.
 * @param classNumber The unique identifier.
 * @return Ok (The request is successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_classidByClassnumberByClassType(classType: string, classNumber: string): Promise<MultifrontTypes.ClassNumberResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/classid-by-classnumber/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{ClassNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processClassidByClassnumberByClassType(_response);
  });
}

function CommerceCollections_processClassidByClassnumberByClassType(response: Response): Promise<MultifrontTypes.ClassNumberResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ClassNumberResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (An error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * The active class number.
 * @param userId (optional)
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_activeClassNumberByClassType(classType: string, userId: number | undefined): Promise<MultifrontTypes.ActiveClassResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/active-class-number";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "userId=" + encodeURIComponent("" + userId);

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (userId === null) throw new Error("The parameter 'userId' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processActiveClassNumberByClassType(_response);
  });
}

function CommerceCollections_processActiveClassNumberByClassType(response: Response): Promise<MultifrontTypes.ActiveClassResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ActiveClassResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request was successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update status by status code.
 * @param classNumber The unique identifier of the class.
 * @param body (optional) The UpdateClassStatusRequestModel containing the updated status information.
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_status(
  classType: string,
  classNumber: string,
  body: MultifrontTypes.UpdateClassStatusRequestModel | undefined
): Promise<MultifrontTypes.UpdateClassStatusResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/status/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processStatus(_response);
  });
}

function CommerceCollections_processStatus(response: Response): Promise<MultifrontTypes.UpdateClassStatusResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateClassStatusResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Processes the checkout receipt for a given shopping cart and sends an email using the specified template.
 * @param classNumber The unique identifier of the shopping cart for which the receipt is being processed.
 * @param statusCode (optional) The identifier for the email template used to format the receipt email.
 * @return ok(Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function CommerceCollections_receiptDetailsByClassType(
  classType: string,
  classNumber: string,
  statusCode: string | undefined
): Promise<MultifrontTypes.ReceiptDetailsResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/receipt-details/{classNumber}";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "statusCode=" + encodeURIComponent("" + statusCode);

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (statusCode === null) throw new Error("The parameter 'statusCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processReceiptDetailsByClassType(_response);
  });
}

function CommerceCollections_processReceiptDetailsByClassType(response: Response): Promise<MultifrontTypes.ReceiptDetailsResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ReceiptDetailsResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("No Content(Indicates that the product quantity could not be updated.)", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the request is invalid.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates class name and returns a response model indicating the updated status of class name.
 * @param classNumber The unique identifier of the class.
 * @param updatedClassName The class name for updating.
 * @return OK(Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function CommerceCollections_className(classType: string, classNumber: string, updatedClassName: string): Promise<MultifrontTypes.ActiveClassResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/class-name/{classNumber}/{updatedClassName}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (updatedClassName === undefined || updatedClassName === null) throw new Error("The parameter 'updatedClassName' must be defined.");
  url_ = url_.replace("{updatedClassName}", encodeURIComponent("" + updatedClassName));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processClassName(_response);
  });
}

function CommerceCollections_processClassName(response: Response): Promise<MultifrontTypes.ActiveClassResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ActiveClassResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates entity details and returns a response model indicating the updated status.
 * @param classNumber The unique identifier of the class.
 * @param body (optional) Details of the entity to update.
 * @return OK
 */

export async function CommerceCollections_entityFields(
  classType: string,
  classNumber: string,
  body: MultifrontTypes.UpdateEntityRequestModel | undefined
): Promise<MultifrontTypes.UpdateEntityResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classType}/entity-fields/{classNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processEntityFields(_response);
  });
}

function CommerceCollections_processEntityFields(response: Response): Promise<MultifrontTypes.UpdateEntityResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateEntityResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Order details to generate an invoice based on order Ids.
 * @param classNumbers Comma-separated string of order identifiers for which invoice details are requested.
 * @return OK(Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function CommerceCollections_multipleClassDetailsByClassType(
  classType: string,
  classNumbers: string
): Promise<MultifrontTypes.CommerceCollectionClassDetailListResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/multiple-class-details/{classNumbers}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumbers === undefined || classNumbers === null) throw new Error("The parameter 'classNumbers' must be defined.");
  url_ = url_.replace("{classNumbers}", encodeURIComponent("" + classNumbers));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processMultipleClassDetailsByClassType(_response);
  });
}

function CommerceCollections_processMultipleClassDetailsByClassType(response: Response): Promise<MultifrontTypes.CommerceCollectionClassDetailListResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CommerceCollectionClassDetailListResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update status of line items of an order.
 * @param classNumber Class Number
 * @param body (optional) Line items details
 * @return OK
 */

export async function CommerceCollections_lineItemStatus(
  classType: string,
  classNumber: string,
  classNumbers: string,
  body: MultifrontTypes.UpdateLineItemStatusRequestModel | undefined
): Promise<MultifrontTypes.UpdateLineItemStatusResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/{classtype}/{classNumbers}/line-item-status";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (classNumbers === undefined || classNumbers === null) throw new Error("The parameter 'classNumbers' must be defined.");
  url_ = url_.replace("{classNumbers}", encodeURIComponent("" + classNumbers));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processLineItemStatus(_response);
  });
}

function CommerceCollections_processLineItemStatus(response: Response): Promise<MultifrontTypes.UpdateLineItemStatusResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.UpdateLineItemStatusResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
         * This method used to Send Email.
         * @param classType Contains the information of classType
         * @param classNumber Class Number
         * @return OK (Indicates that the request was successfully executed, and the response body contains the requested data.)
         */
    
        export async function CommerceCollections_sendEmail(classType:string, classNumber:string): Promise<MultifrontTypes.EmailSendResponseModel> {

        let url_ = baseUrl + "commerceapi/v1/{classType}/send-email/{classNumber}";

        if (classType === undefined || classType === null)
            throw new Error("The parameter 'classType' must be defined.");
        url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
        if (classNumber === undefined || classNumber === null)
            throw new Error("The parameter 'classNumber' must be defined.");
        url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return CommerceCollections_processSendEmail(_response);
        });
    }
   
   function CommerceCollections_processSendEmail(response: Response): Promise<MultifrontTypes.EmailSendResponseModel> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.EmailSendResponseModel);
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
   }
    
   /**
         * This method used to Generate Finalize Number .
         * @param classType Contains the information of classType
         * @param classNumber Contains the information of classType
         * @return OK (Indicates that the request was successfully executed, and the response body contains the requested data.)
         */
    
        export async function CommerceCollections_generateFinalizeNumber(classType:string, classNumber:string): Promise<MultifrontTypes.GenerateFinalizeNumberResponseModel> {

        let url_ = baseUrl + "commerceapi/v1/{classType}/generate-finalize-number/{classNumber}";

        if (classType === undefined || classType === null)
            throw new Error("The parameter 'classType' must be defined.");
        url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
        if (classNumber === undefined || classNumber === null)
            throw new Error("The parameter 'classNumber' must be defined.");
        url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 }
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return CommerceCollections_processGenerateFinalizeNumber(_response);
        });
    }
   
   function CommerceCollections_processGenerateFinalizeNumber(response: Response): Promise<MultifrontTypes.GenerateFinalizeNumberResponseModel> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.GenerateFinalizeNumberResponseModel);
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Success with No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
        return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    /**
         * Updates the details of a finalized. This method processes the provided model and determines if additional calculation details are requested based on the 'expand' parameter.
         * @param classNumber The unique identifier of the update finalize order details.
         * @param expand (optional) The parameter 'Expand' determines calculation details are requested.
         * @return OK
         */
    
    export async function CommerceCollections_finalizeDetails(classType:string, classNumber:string, expand:string[] | undefined): Promise<MultifrontTypes.BooleanResponseModel> {

      let url_ = baseUrl + "commerceapi/v1/{classType}/finalize-details/{classNumber}";
  
      url_ += BuildEndpointQueryString({expand});
  
      if (classType === undefined || classType === null)
          throw new Error("The parameter 'classType' must be defined.");
      url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
      if (classNumber === undefined || classNumber === null)
          throw new Error("The parameter 'classNumber' must be defined.");
      url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
      if (expand === null)
          throw new Error("The parameter 'expand' cannot be null.");
      url_ = url_.replace(/[?&]$/, "");

       let options_: RequestInit = {
          method: "PUT",
          headers: await getHeaders("PUT", String(baseUrl)),
          next: { revalidate: 0 }
      };

      return fetch(url_, options_).then((_response: Response) => {
 
          return CommerceCollections_processFinalizeDetails(_response);
      });
  }
 
 function CommerceCollections_processFinalizeDetails(response: Response): Promise<MultifrontTypes.BooleanResponseModel> {
     const status = response.status;
     let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
  if (status === 200) {
      return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.BooleanResponseModel;
      return result200;
      });
  } else if (status === 201) {
      return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.BooleanResponseModel;
      return result201;
      });
  } else if (status === 204) {
      return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
      return throwException("No Content (Indicates that the request was successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
      });
  } else if (status === 400) {
      return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
      });
  } else if (status === 404) {
      return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
      });
  } else if (status === 500) {
      return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
      });
  } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
  }
  return Promise.resolve<any>(null as any);

  }


function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

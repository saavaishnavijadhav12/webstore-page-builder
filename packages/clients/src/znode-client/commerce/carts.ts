//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as MultifrontTypes from "../../types/interface";

import { BuildEndpointQueryString, getHeaders } from "./BaseClient";

const baseUrl = process.env.API_URL;
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * List of cart items for a specified order.
 * @return OK. Indicates that the request is successfully executed, and the response body contains the requested data.
 */

export async function Carts_itemListByClassType(classType: string, cartNumber: string): Promise<MultifrontTypes.CartListResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/item-list/{cartNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processItemListByClassType(_response);
  });
}

function Carts_processItemListByClassType(response: Response): Promise<MultifrontTypes.CartListResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CartListResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content. Indicates that the request is successfully executed, but the response body does not contain any data.",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request. Indicates that the server could not understand the request due to invalid syntax.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error. Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

 /**
  * Add a product to the cart.
  * @param body (optional) The request model containing details of the product to be added.
  * @return OK
  */
    
 export async function Carts_addToCart(body: MultifrontTypes.AddToCartRequestModel | undefined): Promise<MultifrontTypes.AddToCartResponseModel> {

  let url_ = baseUrl + "commerceapi/v1/carts/add-to-cart";

  url_ = url_.replace(/[?&]$/, "");

const content_ = JSON.stringify(body);

   let options_: RequestInit = {
      body: content_,
      method: "POST",
      cache: "no-store",
      headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {

      return Carts_processAddToCart(_response);
  });
}

function Carts_processAddToCart(response: Response): Promise<MultifrontTypes.AddToCartResponseModel> {
 const status = response.status;
 let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
if (status === 200) {
  return response.text().then((_responseText) => {
  let result200: any = null;
  result200 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.AddToCartResponseModel;
  return result200;
  });
} else if (status === 201) {
  return response.text().then((_responseText) => {
  let result201: any = null;
  result201 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.AddToCartResponseModel;
  return result201;
  });
} else if (status === 204) {
  return response.text().then((_responseText) => {
  let result204: any = null;
  result204 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
  return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
  });
} else if (status === 400) {
  return response.text().then((_responseText) => {
  let result400: any = null;
  result400 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
  return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
  });
} else if (status === 404) {
  return response.text().then((_responseText) => {
  let result404: any = null;
  result404 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
  return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
  });
} else if (status === 500) {
  return response.text().then((_responseText) => {
  let result500: any = null;
  result500 = _responseText === "" ? null : JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail;
  return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
  });
} else if (status !== 200 && status !== 204) {
  return response.text().then((_responseText) => {
  return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  });
}
return Promise.resolve<any>(null as any);

}


/**
 * The count of cart items in the cart.
 * @return Success(Indicates that the request is successfully executed, and the response body contains the requested data.)
 */

export async function Carts_countByClassType(classType: string, cartNumber: string): Promise<MultifrontTypes.CartCountResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/count/{cartNumber}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processCountByClassType(_response);
  });
}

function Carts_processCountByClassType(response: Response): Promise<MultifrontTypes.CartCountResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CartCountResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * This method merge the new cart with old cart and provide merged cart based on the provided MergeCartRequestModel.
 * @param body (optional) The MergeCartRequestModel containing the new and old carts for merging.
 * @return OK
 */

export async function Carts_mergeCart(body: MultifrontTypes.MergeCartRequestModel | undefined): Promise<MultifrontTypes.MergeCartResponseModel> {
  let url_ = baseUrl + "commerceapi/v1/carts/merge-cart";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processMergeCart(_response);
  });
}

function Carts_processMergeCart(response: Response): Promise<MultifrontTypes.MergeCartResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.MergeCartResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.MergeCartResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Success with No Content(Indicates that the product quantity could not be updated.)", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the request is invalid.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Calculated Cart details.
 * @param cartNumber The unique identifier of the cart for which calculation details are requested.
 * @param expand (optional) The parameter 'Expand' determines calculation details are requested.
 * @return Success (The request is successfully executed, and the response body contains the requested data.)
 */

export async function Carts_calculateCartByCartNumber(cartNumber: string, expand: string[] | undefined): Promise<MultifrontTypes.CalculateSummeryResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/carts/calculate-cart/{cartNumber}";

  url_ += BuildEndpointQueryString({ expand });

  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processCalculateCartByCartNumber(_response);
  });
}

function Carts_processCalculateCartByCartNumber(response: Response): Promise<MultifrontTypes.CalculateSummeryResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CalculateSummeryResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * shipping estimate details.
 * @param cartNumber The unique identifier of the shopping cart.
 * @param postalCode The unique identifier of the shopping cart.
 * @return Success (The request is successfully executed, and the response body contains the requested data.)
 */

export async function Carts_shippingEstimatesByClassType(classType: string, cartNumber: string, postalCode: string): Promise<MultifrontTypes.ShippingEstimatesResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/shipping-estimates/{cartNumber}/{postalCode}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  if (postalCode === undefined || postalCode === null) throw new Error("The parameter 'postalCode' must be defined.");
  url_ = url_.replace("{postalCode}", encodeURIComponent("" + postalCode));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processShippingEstimatesByClassType(_response);
  });
}

function Carts_processShippingEstimatesByClassType(response: Response): Promise<MultifrontTypes.ShippingEstimatesResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ShippingEstimatesResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "Success with No Content (The request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * This method get price details based on the provided PriceBySkuRequestModel.
 * @param sku The unique identifier of the shopping cart.
 * @param quantity The unique identifier of the shopping cart.
 * @return OK
 */

export async function Carts_priceBySku(sku: string, quantity: number): Promise<MultifrontTypes.PriceBySkuResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/carts/price/{sku}/{quantity}";

  if (sku === undefined || sku === null) throw new Error("The parameter 'sku' must be defined.");
  url_ = url_.replace("{sku}", encodeURIComponent("" + sku));
  if (quantity === undefined || quantity === null) throw new Error("The parameter 'quantity' must be defined.");
  url_ = url_.replace("{quantity}", encodeURIComponent("" + quantity));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processPriceBySku(_response);
  });
}

function Carts_processPriceBySku(response: Response): Promise<MultifrontTypes.PriceBySkuResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.PriceBySkuResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.PriceBySkuResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Success with No Content(Indicates that the product quantity could not be updated.)", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the request is invalid.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * This method use to validate the cart based on the cart id.
 * @param cartNumber The unique identifier of the shopping cart.
 * @return Success (The request is successfully executed, and the response body contains the requested data.)
 */

export async function Carts_validateCartByCartNumber(cartNumber: string): Promise<MultifrontTypes.CartValidationResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/carts/validate-cart/{cartNumber}";

  if (cartNumber === undefined || cartNumber === null) throw new Error("The parameter 'cartNumber' must be defined.");
  url_ = url_.replace("{cartNumber}", encodeURIComponent("" + cartNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processValidateCartByCartNumber(_response);
  });
}

function Carts_processValidateCartByCartNumber(response: Response): Promise<MultifrontTypes.CartValidationResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CartValidationResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CartValidationResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Success with No Content(Indicates that the product quantity could not be updated.)", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the request is invalid.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * This method get price details based on the CartItemId .
 * @param classNumber The unique identifier of the shopping cart.
 * @param sku The unique identifier of the shopping cart.
 * @return ok(Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Carts_itemPriceByClassType(classType: string, classNumber: string, sku: string): Promise<MultifrontTypes.LineItemPriceResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/{classType}/item-price/{classNumber}/{sku}";

  if (classType === undefined || classType === null) throw new Error("The parameter 'classType' must be defined.");
  url_ = url_.replace("{classType}", encodeURIComponent("" + classType));
  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (sku === undefined || sku === null) throw new Error("The parameter 'sku' must be defined.");
  url_ = url_.replace("{sku}", encodeURIComponent("" + sku));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Carts_processItemPriceByClassType(_response);
  });
}

function Carts_processItemPriceByClassType(response: Response): Promise<MultifrontTypes.LineItemPriceResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.LineItemPriceResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("No Content(Indicates that the product quantity could not be updated.)", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request(Indicates that the request is invalid.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Copy an Class to a cart for the given user.
 * @param classNumber The unique identifier of class.
 * @param targetClassType (optional) The optional unique identifier of class.
 * @return OK
 */

export async function CommerceCollections_savedcartsCopy(classNumber: string, targetClassType: string | undefined): Promise<any> {
  let url_ = baseUrl + "savedcarts-copy/{classNumber}";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "targetClassType=" + encodeURIComponent("" + targetClassType);

  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (targetClassType === null) throw new Error("The parameter 'targetClassType' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CommerceCollections_processSavedcartsCopy(_response);
  });
}

function CommerceCollections_processSavedcartsCopy(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CopiedClassResponseModel);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.CopiedClassResponseModel);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as MultifrontTypes.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

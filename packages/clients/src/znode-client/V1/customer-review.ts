//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from '../../types/multifront-types';
import { addCacheOption, buildEndpointQueryString, getHeaders } from './base';
import { FilterTuple } from '../../types/multifront-types';
import * as MultifrontTypes from '../../types/multifront-types';

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Get list of unassociate profiles.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getUnAssociatedProfileList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.ProfileListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetUnAssociatedProfileList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetUnAssociatedProfileList(_response);
  });
}

function Customer_processGetUnAssociatedProfileList(
  response: Response
): Promise<MultifrontTypes.ProfileListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ProfileListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of associate profiles based on portal.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getAssociatedProfileList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.ProfileListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetAssociatedProfileList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetAssociatedProfileList(_response);
  });
}

function Customer_processGetAssociatedProfileList(
  response: Response
): Promise<MultifrontTypes.ProfileListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ProfileListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Remove associated profiles.
 * @param userId user Id of which profiles need to unassociate profiles.
 * @param body (optional) profileIds to unassociate profiles.
 * @return OK
 */

export async function Customer_unAssociateProfiles(
  userId: number,
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/UnAssociateProfiles/{userId}';

  if (userId === undefined || userId === null)
    throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUnAssociateProfiles(_response);
  });
}

function Customer_processUnAssociateProfiles(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Associate profiles.
 * @param body (optional) model with userId and profileIds to associate profiles.
 * @return OK
 */

export async function Customer_associateProfiles(
  body: Models.ParameterModelUserProfile | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/AssociateProfiles';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processAssociateProfiles(_response);
  });
}

function Customer_processAssociateProfiles(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Set default profile for customer.
 * @param body (optional) model with userId, profileId, default flag.
 * @return OK
 */

export async function Customer_setDefaultProfile(
  body: Models.ParameterModelUserProfile | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/SetDefaultProfile';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processSetDefaultProfile(_response);
  });
}

function Customer_processSetDefaultProfile(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of referral commission type.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getReferralCommissionTypeList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.ReferralCommissionListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetReferralCommissionTypeList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetReferralCommissionTypeList(_response);
  });
}

function Customer_processGetReferralCommissionTypeList(
  response: Response
): Promise<MultifrontTypes.ReferralCommissionListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(
              _responseText
            ) as Models.ReferralCommissionListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get customer affiliate data.
 * @param userId User id of the customer.
 * @param expand (optional)
 * @return OK
 */

export async function Customer_getCustomerAffiliate(
  userId: number,
  expand: string[] | undefined
): Promise<MultifrontTypes.ReferralCommissionResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + 'Customer/GetCustomerAffiliate/{userId}';

  url_ += buildEndpointQueryString({ expand });

  if (userId === undefined || userId === null)
    throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetCustomerAffiliate(_response);
  });
}

function Customer_processGetCustomerAffiliate(
  response: Response
): Promise<MultifrontTypes.ReferralCommissionResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ReferralCommissionResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update customer affiliate data.
 * @param body (optional) Referral commission model to update in database.
 * @return OK
 */

export async function Customer_updateCustomerAffiliate(
  body: Models.ReferralCommissionModel | undefined
): Promise<MultifrontTypes.ReferralCommissionResponse> {
  let url_ = baseUrl + 'Customer/UpdateCustomerAffiliate';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUpdateCustomerAffiliate(_response);
  });
}

function Customer_processUpdateCustomerAffiliate(
  response: Response
): Promise<MultifrontTypes.ReferralCommissionResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ReferralCommissionResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of referral commission for User.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getReferralCommissionList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.ReferralCommissionListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetReferralCommissionList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetReferralCommissionList(_response);
  });
}

function Customer_processGetReferralCommissionList(
  response: Response
): Promise<MultifrontTypes.ReferralCommissionListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(
              _responseText
            ) as Models.ReferralCommissionListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets the address list for user Id.
 * @param expand (optional) Specifies related entities to include in the response,From any related table. For example, passing "ZnodeAddress" allows the inclusion of detailed information from the ZnodeAddress table related to each address.
 * @param filter (optional) Optional. Specifies the criteria to filter the address list, such as filtering by city or state.
 * @param sort (optional) Optional. Specifies the order in which the address list should be sorted, such as by name or date added.
 * @param pageIndex (optional) Required. The zero-based index of the page to retrieve. Used for pagination.
 * @param pageSize (optional) Required. The number of addresses to retrieve per page. Used for pagination.
 * @return OK
 */

export async function Customer_addressList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.AddressListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/AddressList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processAddressList(_response);
  });
}

function Customer_processAddressList(
  response: Response
): Promise<MultifrontTypes.AddressListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create customer Address.
 * @param body (optional) AddressModel model.
 * @return OK
 */

export async function Customer_createCustomerAddress(
  body: Models.AddressModel | undefined
): Promise<MultifrontTypes.AddressResponse> {
  let url_ = baseUrl + 'Customer/CreateCustomerAddress';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processCreateCustomerAddress(_response);
  });
}

function Customer_processCreateCustomerAddress(
  response: Response
): Promise<MultifrontTypes.AddressResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get customer address by filters.
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Customer_getCustomerAddress(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined
): Promise<MultifrontTypes.AddressResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetCustomerAddress';

  url_ += buildEndpointQueryString({ expand, filter });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetCustomerAddress(_response);
  });
}

function Customer_processGetCustomerAddress(
  response: Response
): Promise<MultifrontTypes.AddressResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update customer address.
 * @param body (optional) model to update.
 * @return OK
 */

export async function Customer_updateCustomerAddress(
  body: Models.AddressModel | undefined
): Promise<MultifrontTypes.AddressResponse> {
  let url_ = baseUrl + 'Customer/UpdateCustomerAddress';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUpdateCustomerAddress(_response);
  });
}

function Customer_processUpdateCustomerAddress(
  response: Response
): Promise<MultifrontTypes.AddressResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete customer address.
 * @param body (optional) customer address Ids.
 * @return OK
 */

export async function Customer_deleteCustomerAddress(
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/DeleteCustomerAddress';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processDeleteCustomerAddress(_response);
  });
}

function Customer_processDeleteCustomerAddress(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get the list of search locations on the basis of search term.
 * @param portalId Portal Id.
 * @param searchTerm Search term.
 * @return OK
 */

export async function Customer_getSearchLocation(
  portalId: number,
  searchTerm: string
): Promise<MultifrontTypes.AddressListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + 'Customer/GetSearchLocation/{portalId}/{searchTerm}';

  if (portalId === undefined || portalId === null)
    throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace('{portalId}', encodeURIComponent('' + portalId));
  if (searchTerm === undefined || searchTerm === null)
    throw new Error("The parameter 'searchTerm' must be defined.");
  url_ = url_.replace('{searchTerm}', encodeURIComponent('' + searchTerm));
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetSearchLocation(_response);
  });
}

function Customer_processGetSearchLocation(
  response: Response
): Promise<MultifrontTypes.AddressListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.AddressListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update search address.
 * @param body (optional) AddressModel.
 * @return OK
 */

export async function Customer_updateSearchAddress(
  body: Models.AddressModel | undefined
): Promise<MultifrontTypes.WebStoreAccountResponse> {
  let url_ = baseUrl + 'Customer/UpdateSearchAddress';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUpdateSearchAddress(_response);
  });
}

function Customer_processUpdateSearchAddress(
  response: Response
): Promise<MultifrontTypes.WebStoreAccountResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.WebStoreAccountResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Associate Price List to Customer.
 * @param body (optional) PriceUserModel.
 * @return OK
 */

export async function Customer_associatePriceList(
  body: Models.PriceUserModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/AssociatePriceList';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processAssociatePriceList(_response);
  });
}

function Customer_processAssociatePriceList(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * UnAssociate price lists from customer.
 * @param body (optional) Model contains data to remove.
 * @return OK
 */

export async function Customer_unAssociatePriceList(
  body: Models.PriceUserModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'Customer/UnAssociatePriceList';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUnAssociatePriceList(_response);
  });
}

function Customer_processUnAssociatePriceList(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * To get associated price list precedence value for customer.
 * @param body (optional) priceAccountModel contains priceListId and userId to get precedence value.
 * @return OK
 */

export async function Customer_getAssociatedPriceListPrecedence(
  body: Models.PriceUserModel | undefined
): Promise<MultifrontTypes.PriceUserResponse> {
  let url_ = baseUrl + 'Customer/GetAssociatedPriceListPrecedence';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetAssociatedPriceListPrecedence(_response);
  });
}

function Customer_processGetAssociatedPriceListPrecedence(
  response: Response
): Promise<MultifrontTypes.PriceUserResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.PriceUserResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update associated price list precedence value for account.
 * @param body (optional) PriceUserModel.
 * @return OK
 */

export async function Customer_updateAssociatedPriceListPrecedence(
  body: Models.PriceUserModel | undefined
): Promise<MultifrontTypes.PriceUserResponse> {
  let url_ = baseUrl + 'Customer/UpdateAssociatedPriceListPrecedence';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUpdateAssociatedPriceListPrecedence(_response);
  });
}

function Customer_processUpdateAssociatedPriceListPrecedence(
  response: Response
): Promise<MultifrontTypes.PriceUserResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.PriceUserResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.PriceUserResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get associated role list for an user
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getUserAssociatedRoleList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.RoleListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetUserAssociatedRoleList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetUserAssociatedRoleList(_response);
  });
}

function Customer_processGetUserAssociatedRoleList(
  response: Response
): Promise<MultifrontTypes.RoleListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.RoleListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get roles which are not associated to an user
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Customer_getUserUnAssociatedRoleList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.RoleListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'Customer/GetUserUnAssociatedRoleList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processGetUserUnAssociatedRoleList(_response);
  });
}

function Customer_processGetUserUnAssociatedRoleList(
  response: Response
): Promise<MultifrontTypes.RoleListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.RoleListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Unassociate roles from an associated role list of an user
 * @param roleNames string
 * @param userId string
 * @return OK
 */

export async function Customer_unAssociateRoles(
  roleNames: string,
  userId: string
): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + 'Customer/UnAssociateRoles/{roleNames}/{userId}';

  if (roleNames === undefined || roleNames === null)
    throw new Error("The parameter 'roleNames' must be defined.");
  url_ = url_.replace('{roleNames}', encodeURIComponent('' + roleNames));
  if (userId === undefined || userId === null)
    throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processUnAssociateRoles(_response);
  });
}

function Customer_processUnAssociateRoles(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Associate roles to an user
 * @param roleNames string
 * @param userId string
 * @return OK
 */

export async function Customer_associateRoles(
  roleNames: string,
  userId: string
): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + 'Customer/AssociateRoles/{roleNames}/{userId}';

  if (roleNames === undefined || roleNames === null)
    throw new Error("The parameter 'roleNames' must be defined.");
  url_ = url_.replace('{roleNames}', encodeURIComponent('' + roleNames));
  if (userId === undefined || userId === null)
    throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return Customer_processAssociateRoles(_response);
  });
}

function Customer_processAssociateRoles(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets list of Customer Reviews.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function CustomerReview_list(
  localeId: string,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.CustomerReviewListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'CustomerReview/List/{localeId}';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (localeId === undefined || localeId === null)
    throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace('{localeId}', encodeURIComponent('' + localeId));
  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processList(_response);
  });
}

function CustomerReview_processList(
  response: Response
): Promise<MultifrontTypes.CustomerReviewListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Customer Review details by Customer Review Id.
 * @param customerReviewId Customer Review Id to get Customer Review details.
 * @param localeId Current Locale Id.
 * @return OK
 */

export async function CustomerReview_getCustomerReview(
  customerReviewId: number,
  localeId: string
): Promise<MultifrontTypes.CustomerReviewResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ =
    baseUrl + 'CustomerReview/GetCustomerReview/{customerReviewId}/{localeId}';

  if (customerReviewId === undefined || customerReviewId === null)
    throw new Error("The parameter 'customerReviewId' must be defined.");
  url_ = url_.replace(
    '{customerReviewId}',
    encodeURIComponent('' + customerReviewId)
  );
  if (localeId === undefined || localeId === null)
    throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace('{localeId}', encodeURIComponent('' + localeId));
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processGetCustomerReview(_response);
  });
}

function CustomerReview_processGetCustomerReview(
  response: Response
): Promise<MultifrontTypes.CustomerReviewResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update Customer Review.
 * @param body (optional) model to update.
 * @return OK
 */

export async function CustomerReview_updateCustomerReview(
  body: Models.CustomerReviewModel | undefined
): Promise<MultifrontTypes.CustomerReviewResponse> {
  let url_ = baseUrl + 'CustomerReview/UpdateCustomerReview';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processUpdateCustomerReview(_response);
  });
}

function CustomerReview_processUpdateCustomerReview(
  response: Response
): Promise<MultifrontTypes.CustomerReviewResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete Customer Review.
 * @param body (optional) Customer Review Id.
 * @return OK
 */

export async function CustomerReview_deleteCustomerReview(
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'CustomerReview/DeleteCustomerReview';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processDeleteCustomerReview(_response);
  });
}

function CustomerReview_processDeleteCustomerReview(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Bulk status change for customer review.
 * @param statusId Status of Id to change.
 * @param body (optional) Ids of Customer reviews.
 * @return OK
 */

export async function CustomerReview_bulkStatusChange(
  statusId: string,
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'CustomerReview/BulkStatusChange/{statusId}';

  if (statusId === undefined || statusId === null)
    throw new Error("The parameter 'statusId' must be defined.");
  url_ = url_.replace('{statusId}', encodeURIComponent('' + statusId));
  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processBulkStatusChange(_response);
  });
}

function CustomerReview_processBulkStatusChange(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * create Customer Review.
 * @param body (optional) model to create.
 * @return OK
 */

export async function CustomerReview_create(
  body: Models.CustomerReviewModel | undefined
): Promise<MultifrontTypes.CustomerReviewResponse> {
  let url_ = baseUrl + 'CustomerReview/Create';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CustomerReview_processCreate(_response);
  });
}

function CustomerReview_processCreate(
  response: Response
): Promise<MultifrontTypes.CustomerReviewResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.CustomerReviewResponse);
      return result201;
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'Internal Server Error',
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === '' ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

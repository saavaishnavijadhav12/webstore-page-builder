//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";
import { FilterTuple } from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * To get Portal SEO Setting.
         * @param portalId Portal Id for SEO setting.
         * @return OK
         */
            
export async function SEO_getPortalSEOSetting(portalId:number ): Promise<MultifrontTypes.PortalSEOSettingResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/GetPortalSEOSetting/{portalId}";

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetPortalSEOSetting(_response);
     
        });
    }
   
   
  function SEO_processGetPortalSEOSetting(response: Response): Promise<MultifrontTypes.PortalSEOSettingResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalSEOSettingResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Create portal SEO default settings.
         * @param body (optional) Portal default setting model.
         * @return OK
         */
    
        export async function SEO_createPortalDefaultSetting(body:Models.PortalSEOSettingModel | undefined): Promise<MultifrontTypes.PortalSEOSettingResponse> {

        let url_ = baseUrl + "SEO/CreatePortalDefaultSetting";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return SEO_processCreatePortalDefaultSetting(_response);
        });
    }
   
   function SEO_processCreatePortalDefaultSetting(response: Response): Promise<MultifrontTypes.PortalSEOSettingResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalSEOSettingResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalSEOSettingResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Update an Exiting Portal's SEO Settings.
         * @param body (optional) Portal's SEO settings.
         * @return OK
         */
    
        export async function SEO_updatePortalSEOSetting(body:Models.PortalSEOSettingModel | undefined): Promise<MultifrontTypes.PortalSEOSettingResponse> {

        let url_ = baseUrl + "SEO/UpdatePortalSEOSetting";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return SEO_processUpdatePortalSEOSetting(_response);
        });
    }
   
   function SEO_processUpdatePortalSEOSetting(response: Response): Promise<MultifrontTypes.PortalSEOSettingResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalSEOSettingResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalSEOSettingResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets SEO details for specified SEO details ID.
         * @param itemId ID of Content page/Published product/published category.
         * @param seoTypeId SEO Type Id
         * @param localeId Locale Id
         * @param portalId Portal Id
         * @return OK
         * @deprecated
         */
            
export async function SEO_getSEODetails(itemId:number, seoTypeId:number, localeId:number, portalId:number ): Promise<MultifrontTypes.SEODetailsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/GetSEODetails/{itemId}/{seoTypeId}/{localeId}/{portalId}";

        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (seoTypeId === undefined || seoTypeId === null)
            throw new Error("The parameter 'seoTypeId' must be defined.");
        url_ = url_.replace("{seoTypeId}", encodeURIComponent("" + seoTypeId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetSEODetails(_response);
     
        });
    }
   
   
  function SEO_processGetSEODetails(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets SEO details for specified SEO details ID.
         * @param seoCode SEOCode of Content page/Published product/published category.
         * @param seoTypeId SEO Type Id
         * @param localeId Locale Id
         * @param portalId Portal Id
         * @return OK
         */
            
export async function SEO_getSEODetailsBySEOCode(seoCode:string, seoTypeId:number, localeId:number, portalId:number ): Promise<MultifrontTypes.SEODetailsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/GetSEODetailsBySEOCode/{seoCode}/{seoTypeId}/{localeId}/{portalId}";

        if (seoCode === undefined || seoCode === null)
            throw new Error("The parameter 'seoCode' must be defined.");
        url_ = url_.replace("{seoCode}", encodeURIComponent("" + seoCode));
        if (seoTypeId === undefined || seoTypeId === null)
            throw new Error("The parameter 'seoTypeId' must be defined.");
        url_ = url_.replace("{seoTypeId}", encodeURIComponent("" + seoTypeId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetSEODetailsBySEOCode(_response);
     
        });
    }
   
   
  function SEO_processGetSEODetailsBySEOCode(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets SEO details for specified SEO details ID.
         * @param seoCode SEOCode of Content page/Published product/published category.
         * @param seoTypeId SEO Type Id
         * @param localeId Locale Id
         * @param portalId Portal Id
         * @return OK
         */
            
export async function SEO_getDefaultSEODetails(seoCode:string, seoTypeId:number, localeId:number, portalId:number, itemId:number ): Promise<MultifrontTypes.SEODetailsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/GetDefaultSEODetails/{seoCode}/{seoTypeId}/{localeId}/{portalId}/{itemId}";

        if (seoCode === undefined || seoCode === null)
            throw new Error("The parameter 'seoCode' must be defined.");
        url_ = url_.replace("{seoCode}", encodeURIComponent("" + seoCode));
        if (seoTypeId === undefined || seoTypeId === null)
            throw new Error("The parameter 'seoTypeId' must be defined.");
        url_ = url_.replace("{seoTypeId}", encodeURIComponent("" + seoTypeId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetDefaultSEODetails(_response);
     
        });
    }
   
   
  function SEO_processGetDefaultSEODetails(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets SEO details for specified SEO details ID.
         * @param itemId ID of Content page/Published product/published category.
         * @param seoType SEO Type
         * @param localeId Locale Id
         * @param portalId Portal Id
         * @return OK
         */
            
export async function SEO_getPublishSEODetails(itemId:number, seoType:string, localeId:number, portalId:number, seoCode:string ): Promise<MultifrontTypes.SEODetailsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/GetPublishSEODetails/{itemId}/{seoType}/{localeId}/{portalId}/{seoCode}";

        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (seoType === undefined || seoType === null)
            throw new Error("The parameter 'seoType' must be defined.");
        url_ = url_.replace("{seoType}", encodeURIComponent("" + seoType));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (seoCode === undefined || seoCode === null)
            throw new Error("The parameter 'seoCode' must be defined.");
        url_ = url_.replace("{seoCode}", encodeURIComponent("" + seoCode));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetPublishSEODetails(_response);
     
        });
    }
   
   
  function SEO_processGetPublishSEODetails(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Create SEO details for product/category/content page.
        <param name="model">SEO details model.</param><returns>Returns newly created SEO details model.</returns>
         * @param body (optional) 
         * @return OK
         */
    
        export async function SEO_createSEODetails(body:Models.SEODetailsModel | undefined): Promise<MultifrontTypes.SEODetailsResponse> {

        let url_ = baseUrl + "SEO/CreateSEODetails";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return SEO_processCreateSEODetails(_response);
        });
    }
   
   function SEO_processCreateSEODetails(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Update SEO details for product/category/content page.
         * @param body (optional) SEO details model.
         * @return OK
         */
    
        export async function SEO_updateSEODetails(body:Models.SEODetailsModel | undefined): Promise<MultifrontTypes.SEODetailsResponse> {

        let url_ = baseUrl + "SEO/UpdateSEODetails";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return SEO_processUpdateSEODetails(_response);
        });
    }
   
   function SEO_processUpdateSEODetails(response: Response): Promise<MultifrontTypes.SEODetailsResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Publish Seo
         * @param body (optional) 
         * @return OK
         */
    
        export async function SEO_publishWithPreview(body:Models.SEOPublishModel | undefined): Promise<MultifrontTypes.PublishedResponse> {

        let url_ = baseUrl + "SEO/PublishWithPreview";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return SEO_processPublishWithPreview(_response);
        });
    }
   
   function SEO_processPublishWithPreview(response: Response): Promise<MultifrontTypes.PublishedResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishedResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets a list of Seo Details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function SEO_list(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.SEODetailsListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "SEO/List";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processList(_response);
     
        });
    }
   
   
  function SEO_processList(response: Response): Promise<MultifrontTypes.SEODetailsListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SEODetailsListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets list of Publish Categories.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function SEO_getCategoryListForSEO(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishCategoryListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "SEO/GetCategoryListForSEO";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetCategoryListForSEO(_response);
     
        });
    }
   
   
  function SEO_processGetCategoryListForSEO(response: Response): Promise<MultifrontTypes.PublishCategoryListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishCategoryListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets list of Publish Products.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function SEO_getProductsForSEO(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "SEO/GetProductsForSEO";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processGetProductsForSEO(_response);
     
        });
    }
   
   
  function SEO_processGetProductsForSEO(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Delete Seo Detail by using seoTypeId, portalId and seoCode.
         * @param seoTypeId seoType Id
         * @param portalId portal Id
         * @param seoCode seoCode
         * @return OK
         */
            
export async function SEO_deleteSeoDetail(seoTypeId:number, portalId:number, seoCode:string ): Promise<MultifrontTypes.TrueFalseResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "SEO/DeleteSeoDetail/{seoTypeId}/{portalId}/{seoCode}";

        if (seoTypeId === undefined || seoTypeId === null)
            throw new Error("The parameter 'seoTypeId' must be defined.");
        url_ = url_.replace("{seoTypeId}", encodeURIComponent("" + seoTypeId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (seoCode === undefined || seoCode === null)
            throw new Error("The parameter 'seoCode' must be defined.");
        url_ = url_.replace("{seoCode}", encodeURIComponent("" + seoCode));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return SEO_processDeleteSeoDetail(_response);
     
        });
    }
   
   
  function SEO_processDeleteSeoDetail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import * as MultifrontTypes from "../../types/multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Gets search index data.
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Search_getSearchIndexData(expand: string[] | undefined, filter: FilterTuple[] | undefined): Promise<MultifrontTypes.PortalIndexResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetSearchIndexData";

  url_ += buildEndpointQueryString({ expand, filter });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchIndexData(_response);
  });
}

function Search_processGetSearchIndexData(response: Response): Promise<MultifrontTypes.PortalIndexResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalIndexResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Creates index for search.
 * @param body (optional)
 * @return OK
 */

export async function Search_insertCreateIndexData(body: Models.PortalIndexModel | undefined): Promise<MultifrontTypes.PortalIndexResponse> {
  let url_ = baseUrl + "Search/InsertCreateIndexData";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processInsertCreateIndexData(_response);
  });
}

function Search_processInsertCreateIndexData(response: Response): Promise<MultifrontTypes.PortalIndexResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalIndexResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalIndexResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Creates Index
 * @param indexName Index Name
 * @param revisionType Revision Type
 * @param isPreviewProductionEnabled To check whether preview production is enabled or not.
 * @param isPublishDraftProductsOnly To specify whether to publish only draft products or not.
 * @param portalId Catalog ID for which search index is being made.
 * @param searchIndexMonitorId Search Index monitor for which create index is being called.
 * @param searchIndexServerStatusId Server status ID.
 * @param newIndexName New Name for Index Creation
 * @return OK
 */

export async function Search_createIndex(
  indexName: string,
  revisionType: string,
  isPreviewProductionEnabled: boolean,
  isPublishDraftProductsOnly: boolean,
  portalId: number,
  searchIndexMonitorId: number,
  searchIndexServerStatusId: number,
  newIndexName: string
): Promise<MultifrontTypes.PortalIndexResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ =
    baseUrl +
    "Search/CreateIndex/{indexName}/{revisionType}/{isPreviewProductionEnabled}/{isPublishDraftProductsOnly}/{portalId}/{searchIndexMonitorId}/{searchIndexServerStatusId}/{newIndexName}";

  if (indexName === undefined || indexName === null) throw new Error("The parameter 'indexName' must be defined.");
  url_ = url_.replace("{indexName}", encodeURIComponent("" + indexName));
  if (revisionType === undefined || revisionType === null) throw new Error("The parameter 'revisionType' must be defined.");
  url_ = url_.replace("{revisionType}", encodeURIComponent("" + revisionType));
  if (isPreviewProductionEnabled === undefined || isPreviewProductionEnabled === null) throw new Error("The parameter 'isPreviewProductionEnabled' must be defined.");
  url_ = url_.replace("{isPreviewProductionEnabled}", encodeURIComponent("" + isPreviewProductionEnabled));
  if (isPublishDraftProductsOnly === undefined || isPublishDraftProductsOnly === null) throw new Error("The parameter 'isPublishDraftProductsOnly' must be defined.");
  url_ = url_.replace("{isPublishDraftProductsOnly}", encodeURIComponent("" + isPublishDraftProductsOnly));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (searchIndexMonitorId === undefined || searchIndexMonitorId === null) throw new Error("The parameter 'searchIndexMonitorId' must be defined.");
  url_ = url_.replace("{searchIndexMonitorId}", encodeURIComponent("" + searchIndexMonitorId));
  if (searchIndexServerStatusId === undefined || searchIndexServerStatusId === null) throw new Error("The parameter 'searchIndexServerStatusId' must be defined.");
  url_ = url_.replace("{searchIndexServerStatusId}", encodeURIComponent("" + searchIndexServerStatusId));
  if (newIndexName === undefined || newIndexName === null) throw new Error("The parameter 'newIndexName' must be defined.");
  url_ = url_.replace("{newIndexName}", encodeURIComponent("" + newIndexName));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processCreateIndex(_response);
  });
}

function Search_processCreateIndex(response: Response): Promise<MultifrontTypes.PortalIndexResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalIndexResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Performs full text keyword search.(pass categoryId and other field as per need of filter data.)
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @param body (optional) The model of the keyword search.
 * @return OK
 */

export async function Search_fullTextSearch(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  body: Models.SearchRequestModel | undefined
): Promise<MultifrontTypes.KeywordSearchResponse> {
  let url_ = baseUrl + "Search/FullTextSearch";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processFullTextSearch(_response);
  });
}

function Search_processFullTextSearch(response: Response): Promise<MultifrontTypes.KeywordSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @return OK
 */

export async function Search_getCategoryContent(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number,
  pageSize: number,
  catalogId: number,
  localeId: number,
  portalId: number,
  category: string,
  categoryId: number,
  refineBy: string
): Promise<MultifrontTypes.KeywordSearchResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetCategoryContent/{catalogId}/{localeId}/{portalId}/{category}/{categoryId}/{refineBy}";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "pageIndex=" + encodeURIComponent("" + pageIndex);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "pageSize=" + encodeURIComponent("" + pageSize);

  if (catalogId === undefined || catalogId === null) throw new Error("The parameter 'catalogId' must be defined.");
  url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
  if (localeId === undefined || localeId === null) throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (category === undefined || category === null) throw new Error("The parameter 'category' must be defined.");
  url_ = url_.replace("{category}", encodeURIComponent("" + category));
  if (categoryId === undefined || categoryId === null) throw new Error("The parameter 'categoryId' must be defined.");
  url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
  if (refineBy === undefined || refineBy === null) throw new Error("The parameter 'refineBy' must be defined.");
  url_ = url_.replace("{refineBy}", encodeURIComponent("" + refineBy));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === undefined || pageIndex === null) throw new Error("The parameter 'pageIndex' must be defined and cannot be null.");
  else if (pageSize === undefined || pageSize === null) throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetCategoryContent(_response);
  });
}

function Search_processGetCategoryContent(response: Response): Promise<MultifrontTypes.KeywordSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result204;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieves the content of a category based on provided parameters.
 * @param categoryId The ID of the category.
 * @param catalogId The ID of the catalog.
 * @param localeId The ID of the locale.
 * @param portalId The ID of the portal.
 * @param additionalAttribute Additional attribute information.
 * @param sort (optional) The sorting criteria.
 * @param pageIndex The index of the page.
 * @param pageSize The size of each page.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Category content model.)
 */

export async function Search_categoryContent(
  categoryId: number,
  catalogId: number,
  localeId: number,
  portalId: number,
  additionalAttribute: string,
  sort: { [key: string]: string } | undefined,
  pageIndex: number,
  pageSize: number
): Promise<MultifrontTypes.CategoryContentResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Search/CategoryContent/{categoryId}/{catalogId}/{localeId}";

  url_ += buildEndpointQueryString({ sort, pageIndex, pageSize });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "pageIndex=" + encodeURIComponent("" + pageIndex);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "pageSize=" + encodeURIComponent("" + pageSize);

  if (categoryId === undefined || categoryId === null) throw new Error("The parameter 'categoryId' must be defined.");
  url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
  if (catalogId === undefined || catalogId === null) throw new Error("The parameter 'catalogId' must be defined.");
  url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
  if (localeId === undefined || localeId === null) throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (additionalAttribute === undefined || additionalAttribute === null) throw new Error("The parameter 'additionalAttribute' must be defined.");
  url_ = url_.replace("{additionalAttribute}", encodeURIComponent("" + additionalAttribute));
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === undefined || pageIndex === null) throw new Error("The parameter 'pageIndex' must be defined and cannot be null.");
  else if (pageSize === undefined || pageSize === null) throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processCategoryContent(_response);
  });
}

function Search_processCategoryContent(response: Response): Promise<MultifrontTypes.CategoryContentResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.CategoryContentResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @param body (optional)
 * @return OK
 */

export async function Search_getProductDetailsBySKU(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  body: Models.SearchRequestModel | undefined
): Promise<MultifrontTypes.KeywordSearchResponse> {
  let url_ = baseUrl + "Search/GetProductDetailsBySKU";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetProductDetailsBySKU(_response);
  });
}

function Search_processGetProductDetailsBySKU(response: Response): Promise<MultifrontTypes.KeywordSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @param body (optional)
 * @return OK
 */

export async function Search_facetSearch(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  body: Models.SearchRequestModel | undefined
): Promise<MultifrontTypes.KeywordSearchResponse> {
  let url_ = baseUrl + "Search/FacetSearch";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processFacetSearch(_response);
  });
}

function Search_processFacetSearch(response: Response): Promise<MultifrontTypes.KeywordSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get SEO Url details on the basis of SEO Url.
 * @param seoUrl SEO Url.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getSEOUrlDetails(
  seoUrl: string,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SEOUrlResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetSEOUrlDetails/{seoUrl}";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (seoUrl === undefined || seoUrl === null) throw new Error("The parameter 'seoUrl' must be defined.");
  url_ = url_.replace("{seoUrl}", encodeURIComponent("" + seoUrl));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSEOUrlDetails(_response);
  });
}

function Search_processGetSEOUrlDetails(response: Response): Promise<MultifrontTypes.SEOUrlResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SEOUrlResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Saves boost values for search.
 * @param body (optional) Boost data for product, category and attribute.
 * @return OK
 */

export async function Search_saveBoostValues(body: Models.BoostDataModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Search/SaveBoostValues";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processSaveBoostValues(_response);
  });
}

function Search_processSaveBoostValues(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Deletes the boost value of a product, product-category or field if it is removed.
 * @param body (optional) Boost data model.
 * @return OK
 */

export async function Search_deleteBoostValue(body: Models.BoostDataModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Search/DeleteBoostValue";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processDeleteBoostValue(_response);
  });
}

function Search_processDeleteBoostValue(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets list of global product boost list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getGlobalProductBoostList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchGlobalProductBoostListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetGlobalProductBoostList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetGlobalProductBoostList(_response);
  });
}

function Search_processGetGlobalProductBoostList(response: Response): Promise<MultifrontTypes.SearchGlobalProductBoostListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchGlobalProductBoostListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets global product category boost list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getGlobalProductCategoryBoostList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchGlobalProductCategoryBoostListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetGlobalProductCategoryBoostList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetGlobalProductCategoryBoostList(_response);
  });
}

function Search_processGetGlobalProductCategoryBoostList(response: Response): Promise<MultifrontTypes.SearchGlobalProductCategoryBoostListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchGlobalProductCategoryBoostListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets list of field level boost list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getFieldBoostList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchDocumentMappingListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetFieldBoostList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetFieldBoostList(_response);
  });
}

function Search_processGetFieldBoostList(response: Response): Promise<MultifrontTypes.SearchDocumentMappingListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchDocumentMappingListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}
/**
 * Get Keyword Search Suggestion.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @param body (optional) The model of the keyword search.
 * @return OK
 */

export async function Search_getKeywordSearchSuggestion(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  body: Models.SearchRequestModel | undefined
): Promise<any> {
  let url_ = baseUrl + "Search/GetKeywordSearchSuggestion";
  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };
  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetKeywordSearchSuggestion(_response);
  });
}

function Search_processGetKeywordSearchSuggestion(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}
/**
 * Gets list of search index monitor list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getSearchIndexMonitorList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchIndexMonitorListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetSearchIndexMonitorList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchIndexMonitorList(_response);
  });
}

function Search_processGetSearchIndexMonitorList(response: Response): Promise<MultifrontTypes.SearchIndexMonitorListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchIndexMonitorListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets list of search index server status list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getSearchIndexServerStatusList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchIndexServerStatusListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetSearchIndexServerStatusList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchIndexServerStatusList(_response);
  });
}

function Search_processGetSearchIndexServerStatusList(response: Response): Promise<MultifrontTypes.SearchIndexServerStatusListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchIndexServerStatusListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @param body (optional)
 * @return OK
 */

export async function Search_getSearchProfileProducts(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  body: Models.SearchProfileModel | undefined
): Promise<MultifrontTypes.KeywordSearchResponse> {
  let url_ = baseUrl + "Search/GetSearchProfileProducts";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchProfileProducts(_response);
  });
}

function Search_processGetSearchProfileProducts(response: Response): Promise<MultifrontTypes.KeywordSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete Elastic search index.
 * @param catalogIndexId Catalog index id.
 * @return OK
 */

export async function Search_deleteIndex(catalogIndexId: number): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Search/DeleteIndex/{catalogIndexId}";

  if (catalogIndexId === undefined || catalogIndexId === null) throw new Error("The parameter 'catalogIndexId' must be defined.");
  url_ = url_.replace("{catalogIndexId}", encodeURIComponent("" + catalogIndexId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processDeleteIndex(_response);
  });
}

function Search_processDeleteIndex(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create synonyms for search.
 * @param body (optional) Uses model with data.
 * @return OK
 */

export async function Search_createSearchSynonyms(body: Models.SearchSynonymsModel | undefined): Promise<MultifrontTypes.SearchSynonymsResponse> {
  let url_ = baseUrl + "Search/CreateSearchSynonyms";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processCreateSearchSynonyms(_response);
  });
}

function Search_processCreateSearchSynonyms(response: Response): Promise<MultifrontTypes.SearchSynonymsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchSynonymsResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchSynonymsResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get synonyms data for search.
 * @param searchSynonymsId Uses synonyms id.
 * @param expand (optional)
 * @return OK
 */

export async function Search_getSearchSynonyms(searchSynonymsId: number, expand: string[] | undefined): Promise<MultifrontTypes.SearchSynonymsResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Search/GetSearchSynonyms/{searchSynonymsId}";

  url_ += buildEndpointQueryString({ expand });

  if (searchSynonymsId === undefined || searchSynonymsId === null) throw new Error("The parameter 'searchSynonymsId' must be defined.");
  url_ = url_.replace("{searchSynonymsId}", encodeURIComponent("" + searchSynonymsId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchSynonyms(_response);
  });
}

function Search_processGetSearchSynonyms(response: Response): Promise<MultifrontTypes.SearchSynonymsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchSynonymsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update synonyms data for search.
 * @param body (optional) Uses model with data.
 * @return OK
 */

export async function Search_updateSearchSynonyms(body: Models.SearchSynonymsModel | undefined): Promise<MultifrontTypes.SearchSynonymsResponse> {
  let url_ = baseUrl + "Search/UpdateSearchSynonyms";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processUpdateSearchSynonyms(_response);
  });
}

function Search_processUpdateSearchSynonyms(response: Response): Promise<MultifrontTypes.SearchSynonymsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchSynonymsResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets synonyms list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getSearchSynonymsList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchSynonymsListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetSearchSynonymsList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchSynonymsList(_response);
  });
}

function Search_processGetSearchSynonymsList(response: Response): Promise<MultifrontTypes.SearchSynonymsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchSynonymsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete synonyms by id.
 * @param body (optional) Uses synonyms ids.
 * @return OK
 */

export async function Search_deleteSearchSynonyms(body: Models.ParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Search/DeleteSearchSynonyms";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processDeleteSearchSynonyms(_response);
  });
}

function Search_processDeleteSearchSynonyms(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Write Synonyms file for catalog
 * @param publishCatalogId publish catalog id.
 * @param isSynonymsFile if true create Synonyms file else keyword file.
 * @return OK
 */

export async function Search_writeSearchFile(publishCatalogId: number, isSynonymsFile: boolean): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Search/WriteSearchFile/{publishCatalogId}/{isSynonymsFile}";

  if (publishCatalogId === undefined || publishCatalogId === null) throw new Error("The parameter 'publishCatalogId' must be defined.");
  url_ = url_.replace("{publishCatalogId}", encodeURIComponent("" + publishCatalogId));
  if (isSynonymsFile === undefined || isSynonymsFile === null) throw new Error("The parameter 'isSynonymsFile' must be defined.");
  url_ = url_.replace("{isSynonymsFile}", encodeURIComponent("" + isSynonymsFile));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processWriteSearchFile(_response);
  });
}

function Search_processWriteSearchFile(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets keywords redirect list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Search_getCatalogKeywordsRedirectList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchKeywordsRedirectListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Search/GetCatalogKeywordsRedirectList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetCatalogKeywordsRedirectList(_response);
  });
}

function Search_processGetCatalogKeywordsRedirectList(response: Response): Promise<MultifrontTypes.SearchKeywordsRedirectListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchKeywordsRedirectListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create keywords and its redirected url for search.
 * @param body (optional) Uses model with data.
 * @return OK
 */

export async function Search_createSearchKeywordsRedirect(body: Models.SearchKeywordsRedirectModel | undefined): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  let url_ = baseUrl + "Search/CreateSearchKeywordsRedirect";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processCreateSearchKeywordsRedirect(_response);
  });
}

function Search_processCreateSearchKeywordsRedirect(response: Response): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchKeywordsRedirectResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchKeywordsRedirectResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get keywords data for search.
 * @param searchKeywordsRedirectId Uses keywords id.
 * @param expand (optional)
 * @return OK
 */

export async function Search_getSearchKeywordsRedirect(searchKeywordsRedirectId: number, expand: string[] | undefined): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Search/GetSearchKeywordsRedirect/{searchKeywordsRedirectId}";

  url_ += buildEndpointQueryString({ expand });

  if (searchKeywordsRedirectId === undefined || searchKeywordsRedirectId === null) throw new Error("The parameter 'searchKeywordsRedirectId' must be defined.");
  url_ = url_.replace("{searchKeywordsRedirectId}", encodeURIComponent("" + searchKeywordsRedirectId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processGetSearchKeywordsRedirect(_response);
  });
}

function Search_processGetSearchKeywordsRedirect(response: Response): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchKeywordsRedirectResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update keywords data for search.
 * @param body (optional) Uses model with data.
 * @return OK
 */

export async function Search_updateSearchKeywordsRedirect(body: Models.SearchKeywordsRedirectModel | undefined): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  let url_ = baseUrl + "Search/UpdateSearchKeywordsRedirect";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processUpdateSearchKeywordsRedirect(_response);
  });
}

function Search_processUpdateSearchKeywordsRedirect(response: Response): Promise<MultifrontTypes.SearchKeywordsRedirectResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchKeywordsRedirectResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete keywords by id.
 * @param body (optional) Uses keywords ids.
 * @return OK
 */

export async function Search_deleteSearchKeywordsRedirect(body: Models.ParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Search/DeleteSearchKeywordsRedirect";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processDeleteSearchKeywordsRedirect(_response);
  });
}

function Search_processDeleteSearchKeywordsRedirect(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Check Code exists in DB .
 * @param codeField codeField
 * @return OK
 */

export async function Search_isCodeExistsForSearch(codeField: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Search/IsCodeExistsForSearch/{codeField}";

  if (codeField === undefined || codeField === null) throw new Error("The parameter 'codeField' must be defined.");
  url_ = url_.replace("{codeField}", encodeURIComponent("" + codeField));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Search_processIsCodeExistsForSearch(_response);
  });
}

function Search_processIsCodeExistsForSearch(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}


/**
 * Perform cms page full text keyword search.
 * @param filter (optional)
 * @param body (optional) The model of the keyword search.
 * @return OK
 */

export async function CMSSearchConfiguration_fullTextContentPageSearch(filter: Models.FilterTuple[] | undefined, body: Models.CMSPageSearchRequestModel | undefined): Promise<any> {
  let url_ = baseUrl + "CMSSearchConfiguration/FullTextContentPageSearch";
  url_ += buildEndpointQueryString({ filter });
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return CMSSearchConfiguration_processFullTextContentPageSearch(_response);
  });
}

function CMSSearchConfiguration_processFullTextContentPageSearch(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.CMSKeywordSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}


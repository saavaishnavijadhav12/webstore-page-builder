//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";
import { FilterTuple } from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Get webstore product list.
         * @return OK
         */
            
export async function WebStoreProduct_list( ): Promise<MultifrontTypes.WebStoreProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStoreProduct/List";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreProduct_processList(_response);
     
        });
    }
   
   
  function WebStoreProduct_processList(response: Response): Promise<MultifrontTypes.WebStoreProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreProductListResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get product data by product id.
         * @param productId Product id.
         * @return OK
         */
            
export async function WebStoreProduct_get(productId:number ): Promise<MultifrontTypes.WebStoreProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStoreProduct/Get/{productId}";

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreProduct_processGet(_response);
     
        });
    }
   
   
  function WebStoreProduct_processGet(response: Response): Promise<MultifrontTypes.WebStoreProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreProductResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get list of associated products for product ids.
         * @param ids This helps to pass in query parameter (Comma seperated string)
         * @param targetPublishState (optional) 
         * @param takeFromDraftFirst (optional) 
         * @param localeId (optional) 
         * @param localeIds (optional) 
         * @param portalId (optional) 
         * @param revisionType (optional) 
         * @param publishCataLogId (optional) 
         * @param pimProductId (optional) 
         * @param enableCMSPreview (optional) 
         * @param isDeletePublishSearchIndexSetting (optional) 
         * @return OK
         */
    
        export async function WebStoreProduct_getAssociatedProducts(ids:string, targetPublishState:string | undefined, takeFromDraftFirst:boolean | undefined, localeId:number | undefined, localeIds:number[] | undefined, portalId:number | undefined, revisionType:string | undefined, publishCataLogId:number | undefined, pimProductId:number | undefined, enableCMSPreview:boolean | undefined, isDeletePublishSearchIndexSetting:boolean | undefined): Promise<MultifrontTypes.WebStoreProductListResponse> {

        let url_ = baseUrl + "WebStoreProduct/GetAssociatedProducts";
    
            
            
            
            
            
            
            
            
            
            
            
    
    
            
                    url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "Ids=" + encodeURIComponent("" + ids);
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "TargetPublishState=" + encodeURIComponent("" + targetPublishState);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "TakeFromDraftFirst=" + encodeURIComponent("" + takeFromDraftFirst);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "LocaleId=" + encodeURIComponent("" + localeId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "LocaleIds=" + encodeURIComponent("" + localeIds);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "PortalId=" + encodeURIComponent("" + portalId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "RevisionType=" + encodeURIComponent("" + revisionType);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "publishCataLogId=" + encodeURIComponent("" + publishCataLogId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "PimProductId=" + encodeURIComponent("" + pimProductId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "EnableCMSPreview=" + encodeURIComponent("" + enableCMSPreview);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "IsDeletePublishSearchIndexSetting=" + encodeURIComponent("" + isDeletePublishSearchIndexSetting);
                
            
        
    

        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
        if (targetPublishState === null)
            throw new Error("The parameter 'targetPublishState' cannot be null.");
        if (takeFromDraftFirst === null)
            throw new Error("The parameter 'takeFromDraftFirst' cannot be null.");
        if (localeId === null)
            throw new Error("The parameter 'localeId' cannot be null.");
        if (localeIds === null)
            throw new Error("The parameter 'localeIds' cannot be null.");
        if (portalId === null)
            throw new Error("The parameter 'portalId' cannot be null.");
        if (revisionType === null)
            throw new Error("The parameter 'revisionType' cannot be null.");
        if (publishCataLogId === null)
            throw new Error("The parameter 'publishCataLogId' cannot be null.");
        if (pimProductId === null)
            throw new Error("The parameter 'pimProductId' cannot be null.");
        if (enableCMSPreview === null)
            throw new Error("The parameter 'enableCMSPreview' cannot be null.");
        if (isDeletePublishSearchIndexSetting === null)
            throw new Error("The parameter 'isDeletePublishSearchIndexSetting' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreProduct_processGetAssociatedProducts(_response);
        });
    }
   
   function WebStoreProduct_processGetAssociatedProducts(response: Response): Promise<MultifrontTypes.WebStoreProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreProductListResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get product list by skus.
         * @param ids This helps to pass in query parameter (Comma seperated string)
         * @param targetPublishState (optional) 
         * @param takeFromDraftFirst (optional) 
         * @param localeId (optional) 
         * @param localeIds (optional) 
         * @param portalId (optional) 
         * @param revisionType (optional) 
         * @param publishCataLogId (optional) 
         * @param pimProductId (optional) 
         * @param enableCMSPreview (optional) 
         * @param isDeletePublishSearchIndexSetting (optional) 
         * @return OK
         */
    
        export async function WebStoreProduct_getProductsBySkus(ids:string, targetPublishState:string | undefined, takeFromDraftFirst:boolean | undefined, localeId:number | undefined, localeIds:number[] | undefined, portalId:number | undefined, revisionType:string | undefined, publishCataLogId:number | undefined, pimProductId:number | undefined, enableCMSPreview:boolean | undefined, isDeletePublishSearchIndexSetting:boolean | undefined): Promise<MultifrontTypes.WebStoreProductListResponse> {

        let url_ = baseUrl + "WebStoreProduct/GetProductsBySkus";
    
            
            
            
            
            
            
            
            
            
            
            
    
    
            
                    url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "Ids=" + encodeURIComponent("" + ids);
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "TargetPublishState=" + encodeURIComponent("" + targetPublishState);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "TakeFromDraftFirst=" + encodeURIComponent("" + takeFromDraftFirst);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "LocaleId=" + encodeURIComponent("" + localeId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "LocaleIds=" + encodeURIComponent("" + localeIds);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "PortalId=" + encodeURIComponent("" + portalId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "RevisionType=" + encodeURIComponent("" + revisionType);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "publishCataLogId=" + encodeURIComponent("" + publishCataLogId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "PimProductId=" + encodeURIComponent("" + pimProductId);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "EnableCMSPreview=" + encodeURIComponent("" + enableCMSPreview);
                
            
        
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "IsDeletePublishSearchIndexSetting=" + encodeURIComponent("" + isDeletePublishSearchIndexSetting);
                
            
        
    

        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
        if (targetPublishState === null)
            throw new Error("The parameter 'targetPublishState' cannot be null.");
        if (takeFromDraftFirst === null)
            throw new Error("The parameter 'takeFromDraftFirst' cannot be null.");
        if (localeId === null)
            throw new Error("The parameter 'localeId' cannot be null.");
        if (localeIds === null)
            throw new Error("The parameter 'localeIds' cannot be null.");
        if (portalId === null)
            throw new Error("The parameter 'portalId' cannot be null.");
        if (revisionType === null)
            throw new Error("The parameter 'revisionType' cannot be null.");
        if (publishCataLogId === null)
            throw new Error("The parameter 'publishCataLogId' cannot be null.");
        if (pimProductId === null)
            throw new Error("The parameter 'pimProductId' cannot be null.");
        if (enableCMSPreview === null)
            throw new Error("The parameter 'enableCMSPreview' cannot be null.");
        if (isDeletePublishSearchIndexSetting === null)
            throw new Error("The parameter 'isDeletePublishSearchIndexSetting' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreProduct_processGetProductsBySkus(_response);
        });
    }
   
   function WebStoreProduct_processGetProductsBySkus(response: Response): Promise<MultifrontTypes.WebStoreProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreProductListResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get product highlights for a product on the basis of locale.
         * @param productId Product id.
         * @param localeId Locale id
         * @param body (optional) Model with highlight codes.
         * @return OK
         */
    
        export async function WebStoreProduct_getProductHighlights(productId:number, localeId:number, body:Models.ParameterProductModel | undefined): Promise<MultifrontTypes.HighlightListResponse> {

        let url_ = baseUrl + "WebStoreProduct/GetProductHighlights/{productId}/{localeId}";

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreProduct_processGetProductHighlights(_response);
        });
    }
   
   function WebStoreProduct_processGetProductHighlights(response: Response): Promise<MultifrontTypes.HighlightListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.HighlightListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Send mail for compare product feature.
         * @param body (optional) Product Compare Model.
         * @return OK
         */
    
        export async function WebStoreProduct_sendComparedProductMail(body:Models.ProductCompareModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "WebStoreProduct/SendComparedProductMail";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreProduct_processSendComparedProductMail(_response);
        });
    }
   
   function WebStoreProduct_processSendComparedProductMail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Send mail to a friend.
         * @param body (optional) Email A Friend List Model.
         * @return OK
         */
    
        export async function WebStoreProduct_sendMailToFriend(body:Models.EmailAFriendListModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "WebStoreProduct/SendMailToFriend";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreProduct_processSendMailToFriend(_response);
        });
    }
   
   function WebStoreProduct_processSendMailToFriend(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
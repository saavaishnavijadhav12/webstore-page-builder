//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import * as MultifrontTypes from "../../types/multifront-types";
import * as CommerceMultifrontTypes from "../../types/interface";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Get the list of all Orders.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Order_list(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.OrderListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/List";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processList(_response);
  });
}

function Order_processList(response: Response): Promise<MultifrontTypes.OrderListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get the list of all group orders.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Order_getGroupOrderList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.OrderListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/GetGroupOrderList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetGroupOrderList(_response);
  });
}

function Order_processGetGroupOrderList(response: Response): Promise<MultifrontTypes.OrderListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create new order.
 * @param body (optional) shopping cart model.
 * @return OK
 */

export async function Order_create(body: Models.ShoppingCartModel | undefined): Promise<MultifrontTypes.OrderResponse> {
  let url_ = baseUrl + "Order/Create";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processCreate(_response);
  });
}

function Order_processCreate(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create new order History.
 * @param body (optional) Order History Model.
 * @return OK
 */

export async function Order_createOrderHistory(body: Models.OrderHistoryModel | undefined): Promise<MultifrontTypes.OrderHistoryResponse> {
  let url_ = baseUrl + "Order/CreateOrderHistory";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processCreateOrderHistory(_response);
  });
}

function Order_processCreateOrderHistory(response: Response): Promise<MultifrontTypes.OrderHistoryResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderHistoryResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderHistoryResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update existing order.
 * @param body (optional)
 * @return OK
 */

export async function Order_update(body: Models.OrderModel | undefined): Promise<MultifrontTypes.OrderResponse> {
  let url_ = baseUrl + "Order/Update";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdate(_response);
  });
}

function Order_processUpdate(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param body (optional)
 * @return OK
 */

export async function Order_getOrderDetailsForPayment(body: Models.OrderPaymentCreateModel | undefined): Promise<MultifrontTypes.OrderPaymentResponse> {
  let url_ = baseUrl + "Order/GetOrderDetailsForPayment";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderDetailsForPayment(_response);
  });
}

function Order_processGetOrderDetailsForPayment(response: Response): Promise<MultifrontTypes.OrderPaymentResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderPaymentResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order status.
 * @param body (optional) OrderStateParameterModel
 * @return OK
 */

export async function Order_updateOrderStatus(body: Models.OrderStateParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/UpdateOrderStatus";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderStatus(_response);
  });
}

function Order_processUpdateOrderStatus(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order Shipping Billing Address.
 * @param body (optional) AddressModel
 * @return OK
 */

export async function Order_updateOrderAddress(body: Models.AddressModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/UpdateOrderAddress";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderAddress(_response);
  });
}

function Order_processUpdateOrderAddress(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order status, external id and order notes by order number.
 * @param body (optional) Order details model containing order number, order status code and name, order notes and external id.
 * @return OK
 */

export async function Order_updateOrderDetailsByOrderNumber(body: Models.OrderDetailsModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/UpdateOrderDetailsByOrderNumber";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderDetailsByOrderNumber(_response);
  });
}

function Order_processUpdateOrderDetailsByOrderNumber(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order details by order id.
 * @param orderId order Id
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Order_get(orderId: string, expand: string[] | undefined, filter: FilterTuple[] | undefined): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
  };
  options_ = addCacheOption(filter ?? [], options_);

  let url_ = baseUrl + "Order/Get/{orderId}";
  url_ += buildEndpointQueryString({ expand, filter });
  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGet(_response);
  });
}

function Order_processGet(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order details by order number.
 * @param orderNumber order number
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Order_getByOrderNumber(orderNumber: string, expand: string[] | undefined, filter: FilterTuple[] | undefined): Promise<MultifrontTypes.OrderResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/GetByOrderNumber/{orderNumber}";

  url_ += buildEndpointQueryString({ expand, filter });

  if (orderNumber === undefined || orderNumber === null) throw new Error("The parameter 'orderNumber' must be defined.");
  url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetByOrderNumber(_response);
  });
}

function Order_processGetByOrderNumber(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Resend order confirmation receipt via email.
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Order_resendOrderConfirmationEmail(
  orderId: number,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/ResendOrderConfirmationEmail/{orderId}";

  url_ += buildEndpointQueryString({ expand, filter });

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processResendOrderConfirmationEmail(_response);
  });
}

function Order_processResendOrderConfirmationEmail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Resend order confirmation mail for single cartitem.
 * @param orderId orderId
 * @param cartItemId cartItemId
 * @param expand (optional)
 * @return OK
 */

export async function Order_resendOrderEmailForCartLineItem(orderId: number, cartItemId: number, expand: string[] | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/ResendOrderEmailForCartLineItem/{orderId}/{cartItemId}";

  url_ += buildEndpointQueryString({ expand });

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (cartItemId === undefined || cartItemId === null) throw new Error("The parameter 'cartItemId' must be defined.");
  url_ = url_.replace("{cartItemId}", encodeURIComponent("" + cartItemId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processResendOrderEmailForCartLineItem(_response);
  });
}

function Order_processResendOrderEmailForCartLineItem(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create new user.
 * @param body (optional) user model.
 * @return OK
 */

export async function Order_createNewCustomer(body: Models.UserAddressModel | undefined): Promise<MultifrontTypes.UserAddressResponse> {
  let url_ = baseUrl + "Order/CreateNewCustomer";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processCreateNewCustomer(_response);
  });
}

function Order_processCreateNewCustomer(response: Response): Promise<MultifrontTypes.UserAddressResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserAddressResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserAddressResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order invoice details.
 * @param expand (optional)
 * @param filter (optional)
 * @param body (optional) selected order ids
 * @return OK
 */

export async function Order_getOrderDetailsForInvoice(
  expand: string[] | undefined,
  filter: Models.FilterTuple[] | undefined,
  body: Models.OrderInvoiceDetailsModel | undefined
): Promise<MultifrontTypes.OrderListResponse> {
  let url_ = baseUrl + "Order/GetOrderDetailsForInvoice";

  url_ += buildEndpointQueryString({ expand, filter });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderDetailsForInvoice(_response);
  });
}

function Order_processGetOrderDetailsForInvoice(response: Response): Promise<MultifrontTypes.OrderListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order payment status.
 * @param orderId orderId
 * @param paymentStatus paymentStatus
 * @return OK
 */

export async function Order_updateOrderPaymentStatus(orderId: number, paymentStatus: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/UpdateOrderPaymentStatus/{orderId}/{paymentStatus}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (paymentStatus === undefined || paymentStatus === null) throw new Error("The parameter 'paymentStatus' must be defined.");
  url_ = url_.replace("{paymentStatus}", encodeURIComponent("" + paymentStatus));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderPaymentStatus(_response);
  });
}

function Order_processUpdateOrderPaymentStatus(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order tracking Number.
 * @param orderId orderId
 * @param trackingNumber trackingNumber
 * @return OK
 */

export async function Order_updateTrackingNumberGet(orderId: number, trackingNumber: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/UpdateTrackingNumber/{orderId}/{trackingNumber}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (trackingNumber === undefined || trackingNumber === null) throw new Error("The parameter 'trackingNumber' must be defined.");
  url_ = url_.replace("{trackingNumber}", encodeURIComponent("" + trackingNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateTrackingNumberGet(_response);
  });
}

function Order_processUpdateTrackingNumberGet(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order tracking Number.
 * @param orderId orderId
 * @param trackingNumber trackingNumber
 * @return OK
 */

export async function Order_updateTrackingNumberPut(orderId: number, trackingNumber: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/UpdateTrackingNumber/{orderId}/{trackingNumber}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (trackingNumber === undefined || trackingNumber === null) throw new Error("The parameter 'trackingNumber' must be defined.");
  url_ = url_.replace("{trackingNumber}", encodeURIComponent("" + trackingNumber));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateTrackingNumberPut(_response);
  });
}

function Order_processUpdateTrackingNumberPut(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order tracking Number.
 * @param orderNumber orderNumber
 * @param trackingNumber trackingNumber
 * @return OK
 */

export async function Order_updateTrackingByOrderNumber(orderNumber: string, trackingNumber: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/UpdateTrackingByOrderNumber/{orderNumber}/{trackingNumber}";

  if (orderNumber === undefined || orderNumber === null) throw new Error("The parameter 'orderNumber' must be defined.");
  url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
  if (trackingNumber === undefined || trackingNumber === null) throw new Error("The parameter 'trackingNumber' must be defined.");
  url_ = url_.replace("{trackingNumber}", encodeURIComponent("" + trackingNumber));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateTrackingByOrderNumber(_response);
  });
}

function Order_processUpdateTrackingByOrderNumber(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Add refund payment details.
 * @param body (optional) refundPaymentListModel
 * @return OK
 */

export async function Order_addRefundPaymentDetails(body: Models.OrderItemsRefundModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/AddRefundPaymentDetails";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processAddRefundPaymentDetails(_response);
  });
}

function Order_processAddRefundPaymentDetails(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get orderline items with refund payment left.
 * @param orderDetailsId orderDetailsId
 * @return OK
 */

export async function Order_getOrderLineItemsWithRefund(orderDetailsId: number): Promise<MultifrontTypes.OrderResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetOrderLineItemsWithRefund/{orderDetailsId}";

  if (orderDetailsId === undefined || orderDetailsId === null) throw new Error("The parameter 'orderDetailsId' must be defined.");
  url_ = url_.replace("{orderDetailsId}", encodeURIComponent("" + orderDetailsId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderLineItemsWithRefund(_response);
  });
}

function Order_processGetOrderLineItemsWithRefund(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order details of a single product by order line item id.
 * @param orderLineItemId order line item id.
 * @param expand (optional)
 * @return OK
 */

export async function Order_getOrderByOrderLineItemId(orderLineItemId: number, expand: string[] | undefined): Promise<MultifrontTypes.OrderResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetOrderByOrderLineItemId/{orderLineItemId}";

  url_ += buildEndpointQueryString({ expand });

  if (orderLineItemId === undefined || orderLineItemId === null) throw new Error("The parameter 'orderLineItemId' must be defined.");
  url_ = url_.replace("{orderLineItemId}", encodeURIComponent("" + orderLineItemId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderByOrderLineItemId(_response);
  });
}

function Order_processGetOrderByOrderLineItemId(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Add new order note.
 * @param body (optional) orderNotesModel contains notes details.
 * @return OK
 */

export async function Order_addOrderNote(body: Models.OrderNotesModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/AddOrderNote";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processAddOrderNote(_response);
  });
}

function Order_processAddOrderNote(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order note list.
 * @param omsOrderId order id.
 * @param omsQuoteId oms Quote Id.
 * @return OK
 */

export async function Order_orderNoteList(omsOrderId: number, omsQuoteId: number): Promise<MultifrontTypes.OrderListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/OrderNoteList/{omsOrderId}/{omsQuoteId}";

  if (omsOrderId === undefined || omsOrderId === null) throw new Error("The parameter 'omsOrderId' must be defined.");
  url_ = url_.replace("{omsOrderId}", encodeURIComponent("" + omsOrderId));
  if (omsQuoteId === undefined || omsQuoteId === null) throw new Error("The parameter 'omsQuoteId' must be defined.");
  url_ = url_.replace("{omsQuoteId}", encodeURIComponent("" + omsQuoteId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processOrderNoteList(_response);
  });
}

function Order_processOrderNoteList(response: Response): Promise<MultifrontTypes.OrderListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Payment State list.
 * @return OK
 */

export async function Order_getPaymentStateList(): Promise<MultifrontTypes.OrderPaymentStateResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetPaymentStateList";

  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetPaymentStateList(_response);
  });
}

function Order_processGetPaymentStateList(response: Response): Promise<MultifrontTypes.OrderPaymentStateResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderPaymentStateResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Check inventory and min/max quantity.
 * @param body (optional) shopping cart model.
 * @return OK
 */

export async function Order_checkInventoryAndMinMaxQuantity(body: Models.ShoppingCartModel | undefined): Promise<MultifrontTypes.OrderResponse> {
  let url_ = baseUrl + "Order/CheckInventoryAndMinMaxQuantity";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processCheckInventoryAndMinMaxQuantity(_response);
  });
}

function Order_processCheckInventoryAndMinMaxQuantity(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order state value.
 * @param omsOrderStateId omsOrderStateId
 * @return OK
 */

export async function Order_getOrderStateValueById(omsOrderStateId: number): Promise<MultifrontTypes.OrderStateResponses> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetOrderStateValueById/{omsOrderStateId}";

  if (omsOrderStateId === undefined || omsOrderStateId === null) throw new Error("The parameter 'omsOrderStateId' must be defined.");
  url_ = url_.replace("{omsOrderStateId}", encodeURIComponent("" + omsOrderStateId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderStateValueById(_response);
  });
}

function Order_processGetOrderStateValueById(response: Response): Promise<MultifrontTypes.OrderStateResponses> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderStateResponses);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderStateResponses);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Send returned order receipt via email.
 * @param expand (optional)
 * @param filter (optional)
 * @return OK
 */

export async function Order_sendReturnedOrderEmail(orderId: number, expand: string[] | undefined, filter: FilterTuple[] | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/SendReturnedOrderEmail/{orderId}";

  url_ += buildEndpointQueryString({ expand, filter });

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processSendReturnedOrderEmail(_response);
  });
}

function Order_processSendReturnedOrderEmail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param body (optional)
 * @return OK
 */

export async function Order_sendPOEmail(body: Models.SendInvoiceModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/SendPOEmail";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processSendPOEmail(_response);
  });
}

function Order_processSendPOEmail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update order line item details.
 * @param body (optional) Order Details Model.
 * @return OK
 */

export async function Order_updateOrderLineItems(body: Models.OrderLineItemDataListModel | undefined): Promise<MultifrontTypes.OrderLineItemStatusResponse> {
  let url_ = baseUrl + "Order/UpdateOrderLineItems";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderLineItems(_response);
  });
}

function Order_processUpdateOrderLineItems(response: Response): Promise<MultifrontTypes.OrderLineItemStatusResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderLineItemStatusResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update Order Paypal Payment TransactionId
 * @param orderId orderId
 * @param transactionId transactionId
 * @return OK
 */

export async function Order_updateOrderTransactionId(orderId: number, transactionId: string): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/UpdateOrderTransactionId/{orderId}/{transactionId}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (transactionId === undefined || transactionId === null) throw new Error("The parameter 'transactionId' must be defined.");
  url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processUpdateOrderTransactionId(_response);
  });
}

function Order_processUpdateOrderTransactionId(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Convert quote to the order.
 * @param body (optional)
 * @return OK
 */

export async function Order_convertToOrder(body: Models.AccountQuoteModel | undefined): Promise<MultifrontTypes.OrderResponse> {
  let url_ = baseUrl + "Order/ConvertToOrder";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processConvertToOrder(_response);
  });
}

function Order_processConvertToOrder(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Reorder Complete Order
 * @return OK
 */

export async function Order_reorderCompleteOrder(orderId: number, portalId: number, userId: number): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/ReorderCompleteOrder/{orderId}/{portalId}/{userId}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processReorderCompleteOrder(_response);
  });
}

function Order_processReorderCompleteOrder(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * reorder single line item.
 * @return OK
 */

export async function Order_reorderSinglelineItemOrder(omsOrderLineItemsId: number, portalId: number, userId: number): Promise<MultifrontTypes.TrueFalseResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/ReorderSinglelineItemOrder/{omsOrderLineItemsId}/{portalId}/{userId}";

  if (omsOrderLineItemsId === undefined || omsOrderLineItemsId === null) throw new Error("The parameter 'omsOrderLineItemsId' must be defined.");
  url_ = url_.replace("{omsOrderLineItemsId}", encodeURIComponent("" + omsOrderLineItemsId));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processReorderSinglelineItemOrder(_response);
  });
}

function Order_processReorderSinglelineItemOrder(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get order Receipt details.
 * @param orderId order Id to get Order Details
 * @return OK
 */

export async function Order_getOrderReceiptByOrderId(orderId: number): Promise<MultifrontTypes.OrderResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetOrderReceiptByOrderId/{orderId}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetOrderReceiptByOrderId(_response);
  });
}

function Order_processGetOrderReceiptByOrderId(response: Response): Promise<MultifrontTypes.OrderResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.OrderResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets the address list for user Id.
 * @return OK
 */

export async function Order_getAddressListWithShipment(orderId: number, userId: number): Promise<MultifrontTypes.AddressListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "Order/GetAddressListWithShipment/{orderId}/{userId}";

  if (orderId === undefined || orderId === null) throw new Error("The parameter 'orderId' must be defined.");
  url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processGetAddressListWithShipment(_response);
  });
}

function Order_processGetAddressListWithShipment(response: Response): Promise<MultifrontTypes.AddressListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.AddressListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get the list of failed orders transaction.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function Order_failedOrderTransactionList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.FailedOrderTransactionListResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "Order/FailedOrderTransactionList";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processFailedOrderTransactionList(_response);
  });
}

function Order_processFailedOrderTransactionList(response: Response): Promise<MultifrontTypes.FailedOrderTransactionListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.FailedOrderTransactionListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Save Order Payment Detail
 * @param body (optional) orderPaymentModel
 * @return OK
 */

export async function Order_saveOrderPaymentDetail(body: Models.OrderPaymentDataModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + "Order/SaveOrderPaymentDetail";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Order_processSaveOrderPaymentDetail(_response);
  });
}

function Order_processSaveOrderPaymentDetail(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}
// need to discussed with team
/**
 * Method to check if the current user is an approver to any other user and has approvers itself.
 * @param userId Current User Id.
 * @return OK
 */

export async function AccountQuote_userApproverDetails(userId: number): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "AccountQuote/UserApproverDetails/{userId}";
  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return AccountQuote_processUserApproverDetails(_response);
  });
}

function AccountQuote_processUserApproverDetails(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ApproverDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException("No Content", status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Check if order eligible is for return
 * @param userId userId
 * @param portalId portalId
 * @param orderNumber orderNumber
 * @return OK
 */

export async function RMAReturn_isOrderEligibleForReturn(userId: number, portalId: number, orderNumber: string): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "RMAReturn/IsOrderEligibleForReturn/{userId}/{portalId}/{orderNumber}";
  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (orderNumber === undefined || orderNumber === null) throw new Error("The parameter 'orderNumber' must be defined.");
  url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return RMAReturn_processIsOrderEligibleForReturn(_response);
  });
}

function RMAReturn_processIsOrderEligibleForReturn(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of reason for request.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function RMAConfiguration_getReasonForReturnList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
  };
  options_ = addCacheOption(filter ?? [], options_);

  let url_ = baseUrl + "RMAConfiguration/GetReasonForReturnList";
  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return RMAConfiguration_processGetReasonForReturnList(_response);
  });
}

function RMAConfiguration_processGetReasonForReturnList(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.RequestStatusListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Order Tracking Details on classnumber and emailaddress.
 * @param classNumber The unique identifier of the class for which the details are retrieved.
 * @param emailAddress The email address used to retrieve the associated details.
 * @return OK (Indicates that the request was successfully executed, and the response body contains the requested data.)
 */

export async function Orders_orderTrackingDetailsByClassNumber(
  classNumber: string,
  emailAddress: string
): Promise<CommerceMultifrontTypes.CommerceCollectionClassDetailResponseModel> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "commerceapi/v1/orders/order-tracking-details/{classNumber}/{emailAddress}";

  if (classNumber === undefined || classNumber === null) throw new Error("The parameter 'classNumber' must be defined.");
  url_ = url_.replace("{classNumber}", encodeURIComponent("" + classNumber));
  if (emailAddress === undefined || emailAddress === null) throw new Error("The parameter 'emailAddress' must be defined.");
  url_ = url_.replace("{emailAddress}", encodeURIComponent("" + emailAddress));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Orders_processOrderTrackingDetailsByClassNumber(_response);
  });
}

function Orders_processOrderTrackingDetailsByClassNumber(response: Response): Promise<CommerceMultifrontTypes.CommerceCollectionClassDetailResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as CommerceMultifrontTypes.CommerceCollectionClassDetailResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request was successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the server could not understand the request due to invalid syntax.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";
import { FilterTuple } from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Create Content Page.
         * @param body (optional) ContentPageModel.
         * @return OK
         */
    
        export async function ContentPage_createContentPage(body:Models.ContentPageModel | undefined): Promise<MultifrontTypes.ContentPageResponse> {

        let url_ = baseUrl + "ContentPage/CreateContentPage";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processCreateContentPage(_response);
        });
    }
   
   function ContentPage_processCreateContentPage(response: Response): Promise<MultifrontTypes.ContentPageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get Content Page List.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function ContentPage_getContentPageList(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.ContentPageListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "ContentPage/GetContentPageList";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return ContentPage_processGetContentPageList(_response);
     
        });
    }
   
   
  function ContentPage_processGetContentPageList(response: Response): Promise<MultifrontTypes.ContentPageListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Content Page details by Content Page Id.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function ContentPage_getContentPage(expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.ContentPageResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "ContentPage/GetContentPage";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return ContentPage_processGetContentPage(_response);
     
        });
    }
   
   
  function ContentPage_processGetContentPage(response: Response): Promise<MultifrontTypes.ContentPageResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Update Content Page.
         * @param body (optional) model to update.
         * @return OK
         */
    
        export async function ContentPage_updateContentPage(body:Models.ContentPageModel | undefined): Promise<MultifrontTypes.ContentPageResponse> {

        let url_ = baseUrl + "ContentPage/UpdateContentPage";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processUpdateContentPage(_response);
        });
    }
   
   function ContentPage_processUpdateContentPage(response: Response): Promise<MultifrontTypes.ContentPageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Delete Content Page.
         * @param body (optional) Content page Id.
         * @return OK
         */
    
        export async function ContentPage_deleteContentPage(body:Models.ParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "ContentPage/DeleteContentPage";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processDeleteContentPage(_response);
        });
    }
   
   function ContentPage_processDeleteContentPage(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Publish the content pages
         * @param body (optional) 
         * @return OK
         */
    
        export async function ContentPage_publishContentPageWithPreview(body:Models.ContentPageParameterModel | undefined): Promise<MultifrontTypes.PublishedResponse> {

        let url_ = baseUrl + "ContentPage/PublishContentPageWithPreview";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processPublishContentPageWithPreview(_response);
        });
    }
   
   function ContentPage_processPublishContentPageWithPreview(response: Response): Promise<MultifrontTypes.PublishedResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishedResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets the content page tree.
         * @return OK
         */
            
export async function ContentPage_getTree( ): Promise<MultifrontTypes.ContentPageResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "ContentPage/GetTree";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return ContentPage_processGetTree(_response);
     
        });
    }
   
   
  function ContentPage_processGetTree(response: Response): Promise<MultifrontTypes.ContentPageResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * This method is used to add folder to database.
         * @param body (optional) model to add folder
         * @return OK
         */
    
        export async function ContentPage_addFolder(body:Models.ContentPageFolderModel | undefined): Promise<MultifrontTypes.ContentPageResponse> {

        let url_ = baseUrl + "ContentPage/AddFolder";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processAddFolder(_response);
        });
    }
   
   function ContentPage_processAddFolder(response: Response): Promise<MultifrontTypes.ContentPageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ContentPageResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * This method is used to delete folder.
         * @param body (optional) cms content page id to delete.
         * @return OK
         */
    
        export async function ContentPage_deleteFolder(body:Models.ParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "ContentPage/DeleteFolder";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processDeleteFolder(_response);
        });
    }
   
   function ContentPage_processDeleteFolder(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * This method is used to rename folder.
         * @param body (optional) model to rename folder
         * @return OK
         */
    
        export async function ContentPage_renameFolder(body:Models.ContentPageFolderModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "ContentPage/RenameFolder";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processRenameFolder(_response);
        });
    }
   
   function ContentPage_processRenameFolder(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * This method is used to move one folder to other folder.
         * @param body (optional) ContentPageFolderModel
         * @return OK
         */
    
        export async function ContentPage_moveContentPagesFolder(body:Models.ContentPageFolderModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "ContentPage/MoveContentPagesFolder";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processMoveContentPagesFolder(_response);
        });
    }
   
   function ContentPage_processMoveContentPagesFolder(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Move content pages from one folder to another.
         * @param body (optional) AddPageToFolderModel model.
         * @return OK
         */
    
        export async function ContentPage_movePage(body:Models.AddPageToFolderModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "ContentPage/MovePage";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return ContentPage_processMovePage(_response);
        });
    }
   
   function ContentPage_processMovePage(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get list of content pages.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function WebStoreContentPage_getContentPagesList(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.WebStoreContentPageListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "WebStoreContentPage/GetContentPagesList";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreContentPage_processGetContentPagesList(_response);
     
        });
    }
   
   
  function WebStoreContentPage_processGetContentPagesList(response: Response): Promise<MultifrontTypes.WebStoreContentPageListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreContentPageListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
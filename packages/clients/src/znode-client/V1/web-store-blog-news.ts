//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from '../../types/multifront-types';
import { addCacheOption, buildEndpointQueryString, getHeaders } from './base';
import { FilterTuple } from '../../types/multifront-types';
import * as MultifrontTypes from '../../types/multifront-types';

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Create new blog/news.
 * @param body (optional) BlogNewsModel.
 * @return OK
 */

export async function BlogNews_createBlogNews(
  body: Models.BlogNewsModel | undefined
): Promise<MultifrontTypes.BlogNewsResponse> {
  let url_ = baseUrl + 'BlogNews/CreateBlogNews';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processCreateBlogNews(_response);
  });
}

function BlogNews_processCreateBlogNews(
  response: Response
): Promise<MultifrontTypes.BlogNewsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsResponse);
      return result201;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Blog/News List.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function BlogNews_getBlogNewsList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.BlogNewsListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'BlogNews/GetBlogNewsList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processGetBlogNewsList(_response);
  });
}

function BlogNews_processGetBlogNewsList(
  response: Response
): Promise<MultifrontTypes.BlogNewsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get blog/news details by blog/newsId and localeId.
 * @param blogNewsId Blog/News Id.
 * @param localeId Locale Id.
 * @param expand (optional)
 * @return OK
 */

export async function BlogNews_getBlogNews(
  blogNewsId: number,
  localeId: number,
  expand: string[] | undefined
): Promise<MultifrontTypes.BlogNewsResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + 'BlogNews/GetBlogNews/{blogNewsId}/{localeId}';

  url_ += buildEndpointQueryString({ expand });

  if (blogNewsId === undefined || blogNewsId === null)
    throw new Error("The parameter 'blogNewsId' must be defined.");
  url_ = url_.replace('{blogNewsId}', encodeURIComponent('' + blogNewsId));
  if (localeId === undefined || localeId === null)
    throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace('{localeId}', encodeURIComponent('' + localeId));
  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processGetBlogNews(_response);
  });
}

function BlogNews_processGetBlogNews(
  response: Response
): Promise<MultifrontTypes.BlogNewsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update blog/news.
 * @param body (optional) model to update.
 * @return OK
 */

export async function BlogNews_updateBlogNews(
  body: Models.BlogNewsModel | undefined
): Promise<MultifrontTypes.BlogNewsResponse> {
  let url_ = baseUrl + 'BlogNews/UpdateBlogNews';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processUpdateBlogNews(_response);
  });
}

function BlogNews_processUpdateBlogNews(
  response: Response
): Promise<MultifrontTypes.BlogNewsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete blog(s)/news.
 * @param body (optional) Blog/News Id.
 * @return OK
 */

export async function BlogNews_deleteBlogNews(
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'BlogNews/DeleteBlogNews';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processDeleteBlogNews(_response);
  });
}

function BlogNews_processDeleteBlogNews(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Activate/deactivate blog(s)/news.
 * @param body (optional) Uses Activate Deactivate blog/news model.
 * @return OK
 */

export async function BlogNews_activateDeactivateBlogNews(
  body: Models.BlogNewsParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'BlogNews/ActivateDeactivateBlogNews';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processActivateDeactivateBlogNews(_response);
  });
}

function BlogNews_processActivateDeactivateBlogNews(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Blog/News comment list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function BlogNews_getBlogNewsCommentList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.BlogNewsCommentListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'BlogNews/GetBlogNewsCommentList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processGetBlogNewsCommentList(_response);
  });
}

function BlogNews_processGetBlogNewsCommentList(
  response: Response
): Promise<MultifrontTypes.BlogNewsCommentListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsCommentListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      return throwException('No Content', status, _responseText, _headers);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update blog/news comment.
 * @param body (optional) Blog/News comment model.
 * @return OK
 */

export async function BlogNews_updateBlogNewsComment(
  body: Models.BlogNewsCommentModel | undefined
): Promise<MultifrontTypes.BlogNewsCommentResponse> {
  let url_ = baseUrl + 'BlogNews/UpdateBlogNewsComment';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'PUT',
    headers: await getHeaders('PUT', String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processUpdateBlogNewsComment(_response);
  });
}

function BlogNews_processUpdateBlogNewsComment(
  response: Response
): Promise<MultifrontTypes.BlogNewsCommentResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.BlogNewsCommentResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete blog/news comment(s).
 * @param body (optional) Blog/News comment id.
 * @return OK
 */

export async function BlogNews_deleteBlogNewsComment(
  body: Models.ParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'BlogNews/DeleteBlogNewsComment';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processDeleteBlogNewsComment(_response);
  });
}

function BlogNews_processDeleteBlogNewsComment(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Approve/Disapprove blog/news comment(s).
 * @param body (optional) Uses model with data.
 * @return OK
 */

export async function BlogNews_approveDisapproveBlogNewsComment(
  body: Models.BlogNewsParameterModel | undefined
): Promise<MultifrontTypes.TrueFalseResponse> {
  let url_ = baseUrl + 'BlogNews/ApproveDisapproveBlogNewsComment';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processApproveDisapproveBlogNewsComment(_response);
  });
}

function BlogNews_processApproveDisapproveBlogNewsComment(
  response: Response
): Promise<MultifrontTypes.TrueFalseResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.TrueFalseResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Publish the BlogNews
 * @param body (optional)
 * @return OK
 */

export async function BlogNews_publishBlogNews(
  body: Models.BlogNewsParameterModel | undefined
): Promise<MultifrontTypes.PublishedResponse> {
  let url_ = baseUrl + 'BlogNews/PublishBlogNews';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return BlogNews_processPublishBlogNews(_response);
  });
}

function BlogNews_processPublishBlogNews(
  response: Response
): Promise<MultifrontTypes.PublishedResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.PublishedResponse);
      return result200;
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of blogs/news.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function WebStoreBlogNews_getBlogNewsListForWebstore(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.WebStoreBlogNewsListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'WebStoreBlogNews/GetBlogNewsListForWebstore';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  url_ +=
    (url_.indexOf('?') === -1 ? '?' : '&') +
    'PageSize=' +
    encodeURIComponent('' + pageSize);

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreBlogNews_processGetBlogNewsListForWebstore(_response);
  });
}

function WebStoreBlogNews_processGetBlogNewsListForWebstore(
  response: Response
): Promise<MultifrontTypes.WebStoreBlogNewsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.WebStoreBlogNewsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get blog/news details by blog/newsId and localeId.
 * @param blogNewsId Blog/News Id.
 * @param localeId Locale Id.
 * @return OK
 */

export async function WebStoreBlogNews_getBlogNewsForWebstore(
  blogNewsId: number,
  localeId: number,
  portalId: number,
  activationDate: string
): Promise<MultifrontTypes.WebStoreBlogNewsResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ =
    baseUrl +
    'WebStoreBlogNews/GetBlogNewsForWebstore/{blogNewsId}/{localeId}/{portalId}/{activationDate}';

  if (blogNewsId === undefined || blogNewsId === null)
    throw new Error("The parameter 'blogNewsId' must be defined.");
  url_ = url_.replace('{blogNewsId}', encodeURIComponent('' + blogNewsId));
  if (localeId === undefined || localeId === null)
    throw new Error("The parameter 'localeId' must be defined.");
  url_ = url_.replace('{localeId}', encodeURIComponent('' + localeId));
  if (portalId === undefined || portalId === null)
    throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace('{portalId}', encodeURIComponent('' + portalId));
  if (activationDate === undefined || activationDate === null)
    throw new Error("The parameter 'activationDate' must be defined.");
  url_ = url_.replace(
    '{activationDate}',
    encodeURIComponent('' + activationDate)
  );
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreBlogNews_processGetBlogNewsForWebstore(_response);
  });
}

function WebStoreBlogNews_processGetBlogNewsForWebstore(
  response: Response
): Promise<MultifrontTypes.WebStoreBlogNewsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.WebStoreBlogNewsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Save new blog/news comment.
 * @param body (optional) WebStoreBlogNewsCommentModel.
 * @return OK
 */

export async function WebStoreBlogNews_saveComments(
  body: Models.WebStoreBlogNewsComment | undefined
): Promise<MultifrontTypes.WebStoreBlogNewsCommentResponse> {
  let url_ = baseUrl + 'WebStoreBlogNews/SaveComments';

  url_ = url_.replace(/[?&]$/, '');

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: 'POST',
    cache: 'no-store',
    headers: await getHeaders('POST', String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreBlogNews_processSaveComments(_response);
  });
}

function WebStoreBlogNews_processSaveComments(
  response: Response
): Promise<MultifrontTypes.WebStoreBlogNewsCommentResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(
              _responseText
            ) as Models.WebStoreBlogNewsCommentResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 =
        _responseText === ''
          ? null
          : (JSON.parse(
              _responseText
            ) as Models.WebStoreBlogNewsCommentResponse);
      return result201;
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'Internal Server Error',
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Blog/News comment list.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function WebStoreBlogNews_getUserCommentList(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.WebStoreBlogNewsCommentListResponse> {
  let options_: RequestInit = {
    method: 'GET',
    cache: 'no-store',
    headers: await getHeaders('GET', String(baseUrl)),
  };

  let url_ = baseUrl + 'WebStoreBlogNews/GetUserCommentList';

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  url_ +=
    (url_.indexOf('?') === -1 ? '?' : '&') +
    'PageSize=' +
    encodeURIComponent('' + pageSize);

  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, '');

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreBlogNews_processGetUserCommentList(_response);
  });
}

function WebStoreBlogNews_processGetUserCommentList(
  response: Response
): Promise<MultifrontTypes.WebStoreBlogNewsCommentListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 =
        _responseText === ''
          ? null
          : (JSON.parse(
              _responseText
            ) as Models.WebStoreBlogNewsCommentListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 =
        _responseText === ''
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        'No Content',
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException(
        'An unexpected server error occurred.',
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === '' ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

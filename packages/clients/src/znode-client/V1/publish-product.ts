//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Gets list of Publish Products.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function PublishProduct_listGet(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/List";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processListGet(_response);
     
        });
    }
   
   
  function PublishProduct_processListGet(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets list of Publish Products.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @param body (optional) 
         * @return OK
         */
    
        export async function PublishProduct_listPost(expand:string[] | undefined, filter:Models.FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined, body:Models.ParameterKeyModel | undefined): Promise<MultifrontTypes.PublishProductListResponse> {

        let url_ = baseUrl + "PublishProduct/List";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize, });
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processListPost(_response);
        });
    }
   
   function PublishProduct_processListPost(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get  Publish Product by  Publish Product id.
         * @param publishProductId Publish Product id to get  Publish Product details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishProduct(publishProductId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        options_ = addCacheOption(filter ?? [], options_);

        let url_ = baseUrl + "PublishProduct/GetPublishProduct/{publishProductId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (publishProductId === undefined || publishProductId === null)
            throw new Error("The parameter 'publishProductId' must be defined.");
        url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishProduct(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishProduct(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get parent product.
         * @param parentProductId Parent Product Id to get  Publish Product details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getParentProduct(parentProductId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetParentProduct/{parentProductId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (parentProductId === undefined || parentProductId === null)
            throw new Error("The parameter 'parentProductId' must be defined.");
        url_ = url_.replace("{parentProductId}", encodeURIComponent("" + parentProductId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetParentProduct(_response);
     
        });
    }
   
   
  function PublishProduct_processGetParentProduct(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get only the brief details of a published product .
         * @param publishProductId Publish Product id to get  Publish Product details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishProductBrief(publishProductId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetPublishProductBrief/{publishProductId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (publishProductId === undefined || publishProductId === null)
            throw new Error("The parameter 'publishProductId' must be defined.");
        url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishProductBrief(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishProductBrief(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get only the details of a parent published product .
         * @param publishProductId Publish Product id to get  Publish Product details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getpublishParentProduct(publishProductId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetpublishParentProduct/{publishProductId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (publishProductId === undefined || publishProductId === null)
            throw new Error("The parameter 'publishProductId' must be defined.");
        url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetpublishParentProduct(_response);
     
        });
    }
   
   
  function PublishProduct_processGetpublishParentProduct(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get only the extended details of a published product .
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getExtendedPublishProductDetails(publishProductId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductDTOResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetExtendedPublishProductDetails/{publishProductId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (publishProductId === undefined || publishProductId === null)
            throw new Error("The parameter 'publishProductId' must be defined.");
        url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetExtendedPublishProductDetails(_response);
     
        });
    }
   
   
  function PublishProduct_processGetExtendedPublishProductDetails(response: Response): Promise<MultifrontTypes.PublishProductDTOResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductDTOResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Product Price And Inventory.
         * @param body (optional) 
         * @return OK
         */
    
        export async function PublishProduct_getProductPriceAndInventory(body:Models.ParameterInventoryPriceModel | undefined): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {

        let url_ = baseUrl + "PublishProduct/GetProductPriceAndInventory";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetProductPriceAndInventory(_response);
        });
    }
   
   function PublishProduct_processGetProductPriceAndInventory(response: Response): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ProductInventoryPriceListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get Product Price or Inventory.
         * @param body (optional) 
         * @return OK
         */
    
        export async function PublishProduct_getPriceWithInventory(body:Models.ParameterInventoryPriceListModel | undefined): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {

        let url_ = baseUrl + "PublishProduct/GetPriceWithInventory";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetPriceWithInventory(_response);
        });
    }
   
   function PublishProduct_processGetPriceWithInventory(response: Response): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ProductInventoryPriceListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get product by product sku.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishProductBySKU(productSKU:string, parentProductId:number, parentProductSKU:string, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PublishProductResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetPublishProductBySKU/{productSKU}/{parentProductId}/{parentProductSKU}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (productSKU === undefined || productSKU === null)
            throw new Error("The parameter 'productSKU' must be defined.");
        url_ = url_.replace("{productSKU}", encodeURIComponent("" + productSKU));
        if (parentProductId === undefined || parentProductId === null)
            throw new Error("The parameter 'parentProductId' must be defined.");
        url_ = url_.replace("{parentProductId}", encodeURIComponent("" + parentProductId));
        if (parentProductSKU === undefined || parentProductSKU === null)
            throw new Error("The parameter 'parentProductSKU' must be defined.");
        url_ = url_.replace("{parentProductSKU}", encodeURIComponent("" + parentProductSKU));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishProductBySKU(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishProductBySKU(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * get bundle products.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function PublishProduct_getBundleProducts(expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.WebStoreBundleProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetBundleProducts";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetBundleProducts(_response);
     
        });
    }
   
   
  function PublishProduct_processGetBundleProducts(response: Response): Promise<MultifrontTypes.WebStoreBundleProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreBundleProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get product attributes by product id.
         * @param productId Product id.
         * @param body (optional) ParameterProductModel.
         * @return OK
         */
    
        export async function PublishProduct_getProductAttribute(productId:number, body:Models.ParameterProductModel | undefined): Promise<MultifrontTypes.WebStoreConfigurableAttributeListResponse> {

        let url_ = baseUrl + "PublishProduct/GetProductAttribute/{productId}";

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetProductAttribute(_response);
        });
    }
   
   function PublishProduct_processGetProductAttribute(response: Response): Promise<MultifrontTypes.WebStoreConfigurableAttributeListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreConfigurableAttributeListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get Configurable Product
         * @param expand (optional) 
         * @param body (optional) Model with attributes details.
         * @return OK
         */
    
        export async function PublishProduct_getConfigurableProduct(expand:string[] | undefined, body:Models.ParameterProductModel | undefined): Promise<MultifrontTypes.PublishProductResponse> {

        let url_ = baseUrl + "PublishProduct/GetConfigurableProduct";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand, });
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetConfigurableProduct(_response);
        });
    }
   
   function PublishProduct_processGetConfigurableProduct(response: Response): Promise<MultifrontTypes.PublishProductResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get products associated to main group product.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function PublishProduct_getGroupProducts(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.WebStoreGroupProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetGroupProducts";
    
            
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
                
                            url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "Expand=" + encodeURIComponent("" + expand);
                
            
        
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetGroupProducts(_response);
     
        });
    }
   
   
  function PublishProduct_processGetGroupProducts(response: Response): Promise<MultifrontTypes.WebStoreGroupProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreGroupProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get publish product excluding assigned ids.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @param body (optional) Already assigned Ids
         * @return OK
         */
    
        export async function PublishProduct_unassignedList(expand:string[] | undefined, filter:Models.FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined, body:Models.ParameterModel | undefined): Promise<MultifrontTypes.PublishProductListResponse> {

        let url_ = baseUrl + "PublishProduct/UnassignedList";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize, });
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processUnassignedList(_response);
        });
    }
   
   function PublishProduct_processUnassignedList(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get publish product excluding assigned ids.
         * @param body (optional) 
         * @return OK
         */
    
        export async function PublishProduct_unassignedProducts(body:Models.RequestParameterModel | undefined): Promise<MultifrontTypes.PublishProductListResponse> {

        let url_ = baseUrl + "PublishProduct/UnassignedProducts";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processUnassignedProducts(_response);
        });
    }
   
   function PublishProduct_processUnassignedProducts(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get price for products through ajax async call.
         * @param body (optional) parameters to get product price
         * @return OK
         */
    
        export async function PublishProduct_getProductPrice(body:Models.ParameterInventoryPriceModel | undefined): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {

        let url_ = baseUrl + "PublishProduct/GetProductPrice";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetProductPrice(_response);
        });
    }
   
   function PublishProduct_processGetProductPrice(response: Response): Promise<MultifrontTypes.ProductInventoryPriceListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ProductInventoryPriceListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets list of Publish Products.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishProductForSiteMap(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetPublishProductForSiteMap";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishProductForSiteMap(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishProductForSiteMap(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Gets publish product count.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishProductCount(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.StringResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetPublishProductCount";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishProductCount(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishProductCount(response: Response): Promise<MultifrontTypes.StringResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.StringResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get published product list.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function PublishProduct_getPublishedProductsListData(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetPublishedProductsListData";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetPublishedProductsListData(_response);
     
        });
    }
   
   
  function PublishProduct_processGetPublishedProductsListData(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Product inventory.
         * @param publishProductId Publish Product id to get  Publish Product details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
export async function PublishProduct_getProductInventory(publishProductId: number, expand: string[] | undefined, filter: FilterTuple[] | undefined, cacheInvalidator?: FilterTuple[] | undefined): Promise<MultifrontTypes.ProductInventoryDetailResponse> {

        let options_: RequestInit = {
          method: "GET",
        headers: await getHeaders("GET", String(baseUrl)),
        next: { revalidate: 0 },
    };
    options_ = addCacheOption(cacheInvalidator ?? [], options_);

        let url_ = baseUrl + "PublishProduct/GetProductInventory/{publishProductId}";









                    url_ += buildEndpointQueryString({ expand, filter });





    if (publishProductId === undefined || publishProductId === null)
        throw new Error("The parameter 'publishProductId' must be defined.");
    url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
    if (expand === null)
        throw new Error("The parameter 'expand' cannot be null.");
    if (filter === null)
        throw new Error("The parameter 'filter' cannot be null.");
    url_ = url_.replace(/[?&]$/, "");

        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetProductInventory(_response);
        });
    }
  function PublishProduct_processGetProductInventory(response: Response): Promise<MultifrontTypes.ProductInventoryDetailResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ProductInventoryDetailResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get associated configurable variants.
         * @param productId Product Id
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @return OK
         */
            
export async function PublishProduct_getAssociatedConfigurableVariants(productId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined ): Promise<MultifrontTypes.PublishProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "PublishProduct/GetAssociatedConfigurableVariants/{productId}";
    
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort});
            
            
            
            
    

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processGetAssociatedConfigurableVariants(_response);
     
        });
    }
   
   
  function PublishProduct_processGetAssociatedConfigurableVariants(response: Response): Promise<MultifrontTypes.PublishProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Configurable variants by configurable product Id
         * @param productId Configurable product Id
         * @param additionalAttribute Additional attributes comma seprated codes.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in Category content model.)
         */
            
export async function PublishProduct_associatedConfigurableVariants(productId:number, additionalAttribute:string ): Promise<MultifrontTypes.ConfigurableProductsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "PublishProduct/AssociatedConfigurableVariants/{productId}";

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{ProductId}", encodeURIComponent("" + productId));
        if (additionalAttribute === undefined || additionalAttribute === null)
            throw new Error("The parameter 'additionalAttribute' must be defined.");
        url_ = url_.replace("{additionalAttribute}", encodeURIComponent("" + additionalAttribute));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processAssociatedConfigurableVariants(_response);
     
        });
    }
   
   
  function PublishProduct_processAssociatedConfigurableVariants(response: Response): Promise<MultifrontTypes.ConfigurableProductsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ConfigurableProductsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Submit stock request.
         * @param body (optional) stockNotificationModel
         * @return OK
         */
    
        export async function PublishProduct_submitStockRequest(body:Models.StockNotificationModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "PublishProduct/SubmitStockRequest";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processSubmitStockRequest(_response);
        });
    }
   
   function PublishProduct_processSubmitStockRequest(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Send stock notification.
         * @return OK
         */
            
export async function PublishProduct_sendStockNotification( ): Promise<MultifrontTypes.TrueFalseResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "PublishProduct/SendStockNotification";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PublishProduct_processSendStockNotification(_response);
     
        });
    }
   
   
  function PublishProduct_processSendStockNotification(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get current inventory count of product based on sku's.
         * @param body (optional) productInventoryRequest
         * @return OK
         */
    
        export async function PublishProduct_getInventoryCount_(body:Models.ProductInventoryRequest | undefined): Promise<MultifrontTypes.ProductInventoryResponse> {

        let url_ = baseUrl + "PublishProduct/GetInventoryCount ";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PublishProduct_processGetInventoryCount_(_response);
        });
    }
   
   function PublishProduct_processGetInventoryCount_(response: Response): Promise<MultifrontTypes.ProductInventoryResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ProductInventoryResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
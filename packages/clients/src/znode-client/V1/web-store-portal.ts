//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Get the list of all Portals.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function Portal_getPortalList(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PortalListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/GetPortalList";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalList(_response);
     
        });
    }
   
   
  function Portal_processGetPortalList(response: Response): Promise<MultifrontTypes.PortalListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get all portals on Catalog Id.
         * @return OK
         */
            
export async function Portal_getPortalListByCatalogId(catalogId:number ): Promise<MultifrontTypes.PortalListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalListByCatalogId/{CatalogId}";

        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{CatalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalListByCatalogId(_response);
     
        });
    }
   
   
  function Portal_processGetPortalListByCatalogId(response: Response): Promise<MultifrontTypes.PortalListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get the portal details by portal Id.
         * @param portalId Id of portal to get portal details.
         * @param expand (optional) 
         * @return OK
         */
            
export async function Portal_getPortal(portalId:number, expand:string[] | undefined ): Promise<MultifrontTypes.PortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortal/{portalId}";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand});
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortal(_response);
     
        });
    }
   
   
  function Portal_processGetPortal(response: Response): Promise<MultifrontTypes.PortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Custom portal details by portal Id.
         * @param portalId Id of portal to get Custom portal details.
         * @return OK
         */
            
export async function Portal_getCustomPortalDetails(portalId:number ): Promise<MultifrontTypes.PortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetCustomPortalDetails/{portalId}";

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetCustomPortalDetails(_response);
     
        });
    }
   
   
  function Portal_processGetCustomPortalDetails(response: Response): Promise<MultifrontTypes.PortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get the portal details by Store Code.
         * @param storeCode storeCode to get portal details
         * @param expand (optional) 
         * @return OK
         */
            
export async function Portal_getPortalByStoreCode(storeCode:string, expand:string[] | undefined ): Promise<MultifrontTypes.PortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalByStoreCode/{storeCode}";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand});
            
            
    

        if (storeCode === undefined || storeCode === null)
            throw new Error("The parameter 'storeCode' must be defined.");
        url_ = url_.replace("{storeCode}", encodeURIComponent("" + storeCode));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalByStoreCode(_response);
     
        });
    }
   
   
  function Portal_processGetPortalByStoreCode(response: Response): Promise<MultifrontTypes.PortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Create new Portal.
         * @param body (optional) Portal model.
         * @return OK
         */
    
        export async function Portal_createPortal(body:Models.PortalModel | undefined): Promise<MultifrontTypes.PortalResponse> {

        let url_ = baseUrl + "Portal/CreatePortal";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processCreatePortal(_response);
        });
    }
   
   function Portal_processCreatePortal(response: Response): Promise<MultifrontTypes.PortalResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Update Portal details.
         * @param body (optional) Portal Model.
         * @return OK
         */
    
        export async function Portal_updatePortal(body:Models.PortalModel | undefined): Promise<MultifrontTypes.PortalResponse> {

        let url_ = baseUrl + "Portal/UpdatePortal";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdatePortal(_response);
        });
    }
   
   function Portal_processUpdatePortal(response: Response): Promise<MultifrontTypes.PortalResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Delete a portal by portal Id.
         * @param isDeleteByStoreCode if true then Delete operation will be perform by store code
         * @param body (optional) Id of portal to delete portal.
         * @return OK
         */
    
        export async function Portal_deletePortal(isDeleteByStoreCode:boolean, body:Models.ParameterModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/DeletePortal/{isDeleteByStoreCode}";

        if (isDeleteByStoreCode === undefined || isDeleteByStoreCode === null)
            throw new Error("The parameter 'isDeleteByStoreCode' must be defined.");
        url_ = url_.replace("{isDeleteByStoreCode}", encodeURIComponent("" + isDeleteByStoreCode));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processDeletePortal(_response);
        });
    }
   
   function Portal_processDeletePortal(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Copy and create new store.
         * @param body (optional) Portal model.
         * @return OK
         */
    
        export async function Portal_copyStore(body:Models.PortalModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/CopyStore";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processCopyStore(_response);
        });
    }
   
   function Portal_processCopyStore(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get the list of portal feature list.
         * @return OK
         */
            
export async function Portal_getPortalFeatureList( ): Promise<MultifrontTypes.PortalListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalFeatureList";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalFeatureList(_response);
     
        });
    }
   
   
  function Portal_processGetPortalFeatureList(response: Response): Promise<MultifrontTypes.PortalListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Check portal code already exist or not.
         * @param portalCode portalCode
         * @return OK
         */
            
export async function Portal_isPortalCodeExist(portalCode:string ): Promise<MultifrontTypes.TrueFalseResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/IsPortalCodeExist/{portalCode}";

        if (portalCode === undefined || portalCode === null)
            throw new Error("The parameter 'portalCode' must be defined.");
        url_ = url_.replace("{portalCode}", encodeURIComponent("" + portalCode));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processIsPortalCodeExist(_response);
     
        });
    }
   
   
  function Portal_processIsPortalCodeExist(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get associated warehouse as per selected portal Id.
         * @param portalId portal Id.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function Portal_getAssociatedWarehouseList(portalId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PortalWarehouseResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/GetAssociatedWarehouseList/{portalId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetAssociatedWarehouseList(_response);
     
        });
    }
   
   
  function Portal_processGetAssociatedWarehouseList(response: Response): Promise<MultifrontTypes.PortalWarehouseResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalWarehouseResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Associate Warehouse to portal.
         * @param body (optional) PortalWarehouseModel to be associated.
         * @return OK
         */
    
        export async function Portal_associateWarehouseToStore(body:Models.PortalWarehouseModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/AssociateWarehouseToStore";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processAssociateWarehouseToStore(_response);
        });
    }
   
   function Portal_processAssociateWarehouseToStore(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get active Locale list.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function Portal_localeList(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.LocaleListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/LocaleList";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processLocaleList(_response);
     
        });
    }
   
   
  function Portal_processLocaleList(response: Response): Promise<MultifrontTypes.LocaleListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.LocaleListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Updates Locale.
         * @param body (optional) DefaultGlobalConfigListModel to be updated
         * @return OK
         */
    
        export async function Portal_updateLocale(body:Models.DefaultGlobalConfigListModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/UpdateLocale";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdateLocale(_response);
        });
    }
   
   function Portal_processUpdateLocale(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get portal shipping on the basis of portalId.
         * @param portalId portalId to get portal shipping details.
         * @param expand (optional) 
         * @param filter (optional) 
         * @return OK
         */
            
export async function Portal_getPortalShippingInformation(portalId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined ): Promise<MultifrontTypes.PortalShippingResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/GetPortalShippingInformation/{portalId}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter});
            
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalShippingInformation(_response);
     
        });
    }
   
   
  function Portal_processGetPortalShippingInformation(response: Response): Promise<MultifrontTypes.PortalShippingResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalShippingResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Update portal shipping details.
         * @param body (optional) model to update.
         * @return OK
         */
    
        export async function Portal_updatePortalShipping(body:Models.PortalShippingModel | undefined): Promise<MultifrontTypes.PortalShippingResponse> {

        let url_ = baseUrl + "Portal/UpdatePortalShipping";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdatePortalShipping(_response);
        });
    }
   
   function Portal_processUpdatePortalShipping(response: Response): Promise<MultifrontTypes.PortalShippingResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalShippingResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalShippingResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get portal tax on the basis of portalId.
         * @param portalId portalId to get portal tax details.
         * @param expand (optional) 
         * @return OK
         */
            
export async function Portal_getTaxPortalInformation(portalId:number, expand:string[] | undefined ): Promise<MultifrontTypes.TaxPortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetTaxPortalInformation/{portalId}";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand});
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetTaxPortalInformation(_response);
     
        });
    }
   
   
  function Portal_processGetTaxPortalInformation(response: Response): Promise<MultifrontTypes.TaxPortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TaxPortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Update portal tax details.
         * @param body (optional) Model to update.
         * @return OK
         */
    
        export async function Portal_updateTaxPortal(body:Models.TaxPortalModel | undefined): Promise<MultifrontTypes.TaxPortalResponse> {

        let url_ = baseUrl + "Portal/UpdateTaxPortal";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdateTaxPortal(_response);
        });
    }
   
   function Portal_processUpdateTaxPortal(response: Response): Promise<MultifrontTypes.TaxPortalResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TaxPortalResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TaxPortalResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get portal tracking pixel by portal id.
         * @param portalId Id of portal to get tracking pixel.
         * @param expand (optional) 
         * @return OK
         */
            
export async function Portal_getPortalTrackingPixel(portalId:number, expand:string[] | undefined ): Promise<MultifrontTypes.PortalTrackingPixelResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalTrackingPixel/{portalId}";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand});
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalTrackingPixel(_response);
     
        });
    }
   
   
  function Portal_processGetPortalTrackingPixel(response: Response): Promise<MultifrontTypes.PortalTrackingPixelResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalTrackingPixelResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Save portal tracking pixel.
         * @param body (optional) portalTrackingPixelModel.
         * @return OK
         */
    
        export async function Portal_savePortalTrackingPixel(body:Models.PortalTrackingPixelModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/SavePortalTrackingPixel";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processSavePortalTrackingPixel(_response);
        });
    }
   
   function Portal_processSavePortalTrackingPixel(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Associate/Unassociate tax to portal.
         * @param body (optional) TaxClassPortalModel
         * @return OK
         */
    
        export async function Portal_associateAndUnAssociateTaxClass(body:Models.TaxClassPortalModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/AssociateAndUnAssociateTaxClass";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processAssociateAndUnAssociateTaxClass(_response);
        });
    }
   
   function Portal_processAssociateAndUnAssociateTaxClass(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Set default tax for portal.
         * @param body (optional) TaxClassPortalModel
         * @return OK
         */
    
        export async function Portal_setPortalDefaultTax(body:Models.TaxClassPortalModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/SetPortalDefaultTax";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processSetPortalDefaultTax(_response);
        });
    }
   
   function Portal_processSetPortalDefaultTax(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        let result201: any = null;
        result201 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result201;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets list of publish portals status.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function Portal_getPortalPublishStatus(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PublishPortalLogListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/GetPortalPublishStatus";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalPublishStatus(_response);
     
        });
    }
   
   
  function Portal_processGetPortalPublishStatus(response: Response): Promise<MultifrontTypes.PublishPortalLogListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PublishPortalLogListResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get robots.txt data.
         * @param portalId portal id
         * @param expand (optional) 
         * @return OK
         */
            
export async function Portal_getRobotsTxt(portalId:number, expand:string[] | undefined ): Promise<MultifrontTypes.RobotsTxtResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetRobotsTxt/{portalId}";
    
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand});
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetRobotsTxt(_response);
     
        });
    }
   
   
  function Portal_processGetRobotsTxt(response: Response): Promise<MultifrontTypes.RobotsTxtResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.RobotsTxtResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Save robots.txt data.
         * @param body (optional) Robots Txt Model
         * @return OK
         */
    
        export async function Portal_saveRobotsTxt(body:Models.RobotsTxtModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/SaveRobotsTxt";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processSaveRobotsTxt(_response);
        });
    }
   
   function Portal_processSaveRobotsTxt(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @return OK
         */
            
export async function Portal_getPortalApprovalDetailsById(portalId:number, expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined ): Promise<MultifrontTypes.PortalApprovalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/GetPortalApprovalDetailsById/{portalId}";
    
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort});
            
            
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalApprovalDetailsById(_response);
     
        });
    }
   
   
  function Portal_processGetPortalApprovalDetailsById(response: Response): Promise<MultifrontTypes.PortalApprovalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalApprovalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Portal Approval type list
         * @return OK
         */
            
export async function Portal_getPortalApprovalTypeList( ): Promise<MultifrontTypes.PortalApprovalTypeListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalApprovalTypeList";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalApprovalTypeList(_response);
     
        });
    }
   
   
  function Portal_processGetPortalApprovalTypeList(response: Response): Promise<MultifrontTypes.PortalApprovalTypeListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalApprovalTypeListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get Portal Approval level list
         * @return OK
         */
            
export async function Portal_getPortalApprovalLevelList( ): Promise<MultifrontTypes.PortalApprovalLevelListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalApprovalLevelList";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalApprovalLevelList(_response);
     
        });
    }
   
   
  function Portal_processGetPortalApprovalLevelList(response: Response): Promise<MultifrontTypes.PortalApprovalLevelListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PortalApprovalLevelListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * @return OK
         */
            
export async function Portal_getPortalApproverList(portalApprovalId:number ): Promise<MultifrontTypes.UserApproverListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetPortalApproverList/{portalApprovalId}";

        if (portalApprovalId === undefined || portalApprovalId === null)
            throw new Error("The parameter 'portalApprovalId' must be defined.");
        url_ = url_.replace("{portalApprovalId}", encodeURIComponent("" + portalApprovalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetPortalApproverList(_response);
     
        });
    }
   
   
  function Portal_processGetPortalApproverList(response: Response): Promise<MultifrontTypes.UserApproverListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.UserApproverListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Save/Update the Portal Approval details.
         * @param body (optional) Portal Approval Model.
         * @return OK
         */
    
        export async function Portal_saveUpdatePortalApprovalDetails(body:Models.PortalApprovalModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/SaveUpdatePortalApprovalDetails";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processSaveUpdatePortalApprovalDetails(_response);
        });
    }
   
   function Portal_processSaveUpdatePortalApprovalDetails(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get the list of Sort Setting.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function Portal_sortlist(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.SortSettingListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/Sortlist";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processSortlist(_response);
     
        });
    }
   
   
  function Portal_processSortlist(response: Response): Promise<MultifrontTypes.SortSettingListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SortSettingListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get the list of Page Setting.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param pageIndex (optional) 
         * @param pageSize (optional) 
         * @return OK
         */
            
export async function Portal_pagelist(expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, pageIndex:number | undefined, pageSize:number | undefined ): Promise<MultifrontTypes.PageSettingListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "Portal/Pagelist";
    
            
            
        
            
            
        
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort,  pageIndex,  pageSize});
            
            
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processPagelist(_response);
     
        });
    }
   
   
  function Portal_processPagelist(response: Response): Promise<MultifrontTypes.PageSettingListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PageSettingListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * @param body (optional) Association model.
         * @return OK
         */
    
        export async function Portal_removeAssociatedSortSettings(body:Models.SortSettingAssociationModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/RemoveAssociatedSortSettings";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processRemoveAssociatedSortSettings(_response);
        });
    }
   
   function Portal_processRemoveAssociatedSortSettings(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * @param body (optional) Association model.
         * @return OK
         */
    
        export async function Portal_removeAssociatedPageSettings(body:Models.PageSettingAssociationModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/RemoveAssociatedPageSettings";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processRemoveAssociatedPageSettings(_response);
        });
    }
   
   function Portal_processRemoveAssociatedPageSettings(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Associate sort settings.
         * @param body (optional) Association model.
         * @return OK
         */
    
        export async function Portal_associateSortSettings(body:Models.SortSettingAssociationModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/AssociateSortSettings";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processAssociateSortSettings(_response);
        });
    }
   
   function Portal_processAssociateSortSettings(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Associate page settings.
         * @param body (optional) Association model.
         * @return OK
         */
    
        export async function Portal_associatePageSettings(body:Models.PageSettingAssociationModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/AssociatePageSettings";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processAssociatePageSettings(_response);
        });
    }
   
   function Portal_processAssociatePageSettings(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Update portal page setting model
         * @param body (optional) 
         * @return OK
         */
    
        export async function Portal_updatePortalPageSetting(body:Models.PortalPageSettingModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/UpdatePortalPageSetting";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdatePortalPageSetting(_response);
        });
    }
   
   function Portal_processUpdatePortalPageSetting(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get Barcode scanner setting details.
         * @return OK
         */
            
export async function Portal_getBarcodeScanner( ): Promise<MultifrontTypes.BarcodeReaderModelResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetBarcodeScanner";

        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetBarcodeScanner(_response);
     
        });
    }
   
   
  function Portal_processGetBarcodeScanner(response: Response): Promise<MultifrontTypes.BarcodeReaderModelResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.BarcodeReaderModelResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get BStore Setting
         * @return OK
         */
            
export async function Portal_getBStoreSetting(portalId:number ): Promise<MultifrontTypes.BStoresSettingResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "Portal/GetBStoreSetting/{portalId}";

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return Portal_processGetBStoreSetting(_response);
     
        });
    }
   
   
  function Portal_processGetBStoreSetting(response: Response): Promise<MultifrontTypes.BStoresSettingResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.BStoresSettingResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Update the BStore Setting details.
         * @param body (optional) BStore Setting  Model.
         * @return OK
         */
    
        export async function Portal_updateBStoreSetting(body:Models.BStoresSettingModel | undefined): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/UpdateBStoreSetting";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processUpdateBStoreSetting(_response);
        });
    }
   
   function Portal_processUpdateBStoreSetting(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Check Code exists in DB .
         * @param codeField codeField
         * @return OK
         */
    
        export async function Portal_isCodeExistsForStore(codeField:string): Promise<MultifrontTypes.TrueFalseResponse> {

        let url_ = baseUrl + "Portal/IsCodeExistsForStore/{codeField}";

        if (codeField === undefined || codeField === null)
            throw new Error("The parameter 'codeField' must be defined.");
        url_ = url_.replace("{codeField}", encodeURIComponent("" + codeField));
        url_ = url_.replace(/[?&]$/, "");

         let options_: RequestInit = {
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return Portal_processIsCodeExistsForStore(_response);
        });
    }
   
   function Portal_processIsCodeExistsForStore(response: Response): Promise<MultifrontTypes.TrueFalseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.TrueFalseResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get portal information for a portal by its id.
         * @param portalId Id of portal to get portal information.
         * @return OK
         */
            
export async function WebStorePortal_getPortal(portalId:number ): Promise<MultifrontTypes.WebStorePortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStorePortal/GetPortal/{portalId}";

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStorePortal_processGetPortal(_response);
     
        });
    }
   
   
  function WebStorePortal_processGetPortal(response: Response): Promise<MultifrontTypes.WebStorePortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStorePortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get portal information for a portal by its id.
         * @param portalId Id of portal to get portal information.
         * @param localeId Locale Id of the portal.
         * @param applicationType Application Type of the portal which has to be picked.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @return OK
         */
            
export async function WebStorePortal_getPortalFromApplicationType(portalId:number, localeId:number, applicationType: Models.ApplicationTypesEnum, expand:string[] | undefined, filter:FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined ): Promise<MultifrontTypes.WebStorePortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
        };

        let url_ = baseUrl + "WebStorePortal/GetPortalFromApplicationType/{portalId}/{localeId}/{applicationType}";
    
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort});
            
            
            
            
    

        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (applicationType === undefined || applicationType === null)
            throw new Error("The parameter 'applicationType' must be defined.");
        url_ = url_.replace("{applicationType}", encodeURIComponent("" + applicationType));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStorePortal_processGetPortalFromApplicationType(_response);
     
        });
    }
   
   
  function WebStorePortal_processGetPortalFromApplicationType(response: Response): Promise<MultifrontTypes.WebStorePortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStorePortalResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStorePortalResponse;
        return result204;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get portal information for a portal by its domainName.
         * @param domainName Id of portal to get portal information.
         * @return OK
         */
            
export async function WebStorePortal_getPortalByDomain(domainName:string ): Promise<MultifrontTypes.WebStorePortalResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStorePortal/GetPortalByDomain/{domainName}";

        if (domainName === undefined || domainName === null)
            throw new Error("The parameter 'domainName' must be defined.");
        url_ = url_.replace("{domainName}", encodeURIComponent("" + domainName));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStorePortal_processGetPortalByDomain(_response);
     
        });
    }
   
   
  function WebStorePortal_processGetPortalByDomain(response: Response): Promise<MultifrontTypes.WebStorePortalResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStorePortalResponse;
        return result200;
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
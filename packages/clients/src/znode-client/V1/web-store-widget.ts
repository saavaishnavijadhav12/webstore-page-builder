//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "../../types/multifront-types";
import * as MultifrontTypes  from "../../types/multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "../../types/multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Get slider data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getSlider(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.SliderResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetSlider/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetSlider(_response);
        });
    }
   
   function WebStoreWidget_processGetSlider(response: Response): Promise<MultifrontTypes.SliderResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.SliderResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get slider data.
         * @param cmsMappingId CMS Mapping Id
         * @param widgetKey Widget Key
         * @param typeOfMapping Type of Mapping
         * @param localeId Locale Id
         * @return OK
         */
            
export async function WebStoreWidget_getSliderDetails(cmsMappingId:number, widgetKey:string, typeOfMapping:string, localeId:number ): Promise<MultifrontTypes.ManageMessageResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStoreWidget/GetSliderDetails/{cmsMappingId}/{widgetKey}/{typeOfMapping}/{localeId}";

        if (cmsMappingId === undefined || cmsMappingId === null)
            throw new Error("The parameter 'cmsMappingId' must be defined.");
        url_ = url_.replace("{cmsMappingId}", encodeURIComponent("" + cmsMappingId));
        if (widgetKey === undefined || widgetKey === null)
            throw new Error("The parameter 'widgetKey' must be defined.");
        url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
        if (typeOfMapping === undefined || typeOfMapping === null)
            throw new Error("The parameter 'typeOfMapping' must be defined.");
        url_ = url_.replace("{typeOfMapping}", encodeURIComponent("" + typeOfMapping));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreWidget_processGetSliderDetails(_response);
     
        });
    }
   
   
  function WebStoreWidget_processGetSliderDetails(response: Response): Promise<MultifrontTypes.ManageMessageResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ManageMessageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get product list widget data.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getProducts(expand:string[] | undefined, filter:Models.FilterTuple[] | undefined, key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreWidgetProductListResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetProducts/{key}";
    
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter, });
            
            
            
    

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetProducts(_response);
        });
    }
   
   function WebStoreWidget_processGetProducts(response: Response): Promise<MultifrontTypes.WebStoreWidgetProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreWidgetProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get link widget data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getLinkWidget(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreLinkWidgetResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetLinkWidget/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetLinkWidget(_response);
        });
    }
   
   function WebStoreWidget_processGetLinkWidget(response: Response): Promise<MultifrontTypes.WebStoreLinkWidgetResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreLinkWidgetResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get categories list widget data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getCategories(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreWidgetCategoryListResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetCategories/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetCategories(_response);
        });
    }
   
   function WebStoreWidget_processGetCategories(response: Response): Promise<MultifrontTypes.WebStoreWidgetCategoryListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreWidgetCategoryListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get link product list widget data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getLinkProductList(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreLinkProductListResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetLinkProductList/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetLinkProductList(_response);
        });
    }
   
   function WebStoreWidget_processGetLinkProductList(response: Response): Promise<MultifrontTypes.WebStoreLinkProductListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreLinkProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Gets link product list
         * @param productId Product Id
         * @param portalId Portal Id
         * @param publishCatalogId Publish Catalog Id
         * @param localeId Locale Id
         * @return OK
         */
            
export async function WebStoreWidget_getLinkProducts(productId:number, portalId:number, publishCatalogId:number, localeId:number ): Promise<MultifrontTypes.WebStoreLinkProductListResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStoreWidget/GetLinkProducts/{productId}/{portalId}/{publishCatalogId}/{localeId}";

        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (portalId === undefined || portalId === null)
            throw new Error("The parameter 'portalId' must be defined.");
        url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
        if (publishCatalogId === undefined || publishCatalogId === null)
            throw new Error("The parameter 'publishCatalogId' must be defined.");
        url_ = url_.replace("{publishCatalogId}", encodeURIComponent("" + publishCatalogId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreWidget_processGetLinkProducts(_response);
     
        });
    }
   
   
  function WebStoreWidget_processGetLinkProducts(response: Response): Promise<MultifrontTypes.WebStoreLinkProductListResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreLinkProductListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Get tag manager widget data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getTagManager(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.ManageMessageResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetTagManager/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetTagManager(_response);
        });
    }
   
   function WebStoreWidget_processGetTagManager(response: Response): Promise<MultifrontTypes.ManageMessageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ManageMessageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get the Media Widget Details
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getMediaWidgetDetails(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.ManageMessageResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetMediaWidgetDetails/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetMediaWidgetDetails(_response);
        });
    }
   
   function WebStoreWidget_processGetMediaWidgetDetails(response: Response): Promise<MultifrontTypes.ManageMessageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ManageMessageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get brand list widget data.
         * @param key Unique key for a widget.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getBrands(key:string, body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreWidgetBrandListResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetBrands/{key}";

        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetBrands(_response);
        });
    }
   
   function WebStoreWidget_processGetBrands(response: Response): Promise<MultifrontTypes.WebStoreWidgetBrandListResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreWidgetBrandListResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get brand list widget data.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getFormConfigurationByCMSMappingId(body:Models.WebStoreWidgetFormParameters | undefined): Promise<MultifrontTypes.WebStoreWidgetFormResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetFormConfigurationByCMSMappingId";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetFormConfigurationByCMSMappingId(_response);
        });
    }
   
   function WebStoreWidget_processGetFormConfigurationByCMSMappingId(response: Response): Promise<MultifrontTypes.WebStoreWidgetFormResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreWidgetFormResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get Search widget data.
         * @param expand (optional) 
         * @param filter (optional) 
         * @param sort (optional) 
         * @param body (optional) search widget parameter model
         * @return OK
         */
    
        export async function WebStoreWidget_getSearchWidgetData(expand:string[] | undefined, filter:Models.FilterTuple[] | undefined, sort:{ [key: string]: string; } | undefined, body:Models.WebStoreSearchWidgetParameterModel | undefined): Promise<MultifrontTypes.WebStoreWidgetSearchResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetSearchWidgetData";
    
            
            
        
            
            
        
            
            
        
    
    
                            url_ += buildEndpointQueryString({ expand,  filter,  sort, });
            
            
            
            
    

        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetSearchWidgetData(_response);
        });
    }
   
   function WebStoreWidget_processGetSearchWidgetData(response: Response): Promise<MultifrontTypes.WebStoreWidgetSearchResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreWidgetSearchResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get container data.
         * @param body (optional) Web Store Widget Parameter Model.
         * @return OK
         */
    
        export async function WebStoreWidget_getContainer(body:Models.WebStoreWidgetParameterModel | undefined): Promise<MultifrontTypes.ManageMessageResponse> {

        let url_ = baseUrl + "WebStoreWidget/GetContainer";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: await getHeaders("PUT", String(baseUrl)),
            next: { revalidate: 0 },
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return WebStoreWidget_processGetContainer(_response);
        });
    }
   
   function WebStoreWidget_processGetContainer(response: Response): Promise<MultifrontTypes.ManageMessageResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ManageMessageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Get container data.
         * @param cmsMappingId CMS Mapping Id
         * @param widgetKey Widget Key
         * @param typeOfMapping Type of Mapping
         * @param localeId Locale Id
         * @return OK
         */
            
export async function WebStoreWidget_getContainerDetails(cmsMappingId:number, widgetKey:string, typeOfMapping:string, localeId:number ): Promise<MultifrontTypes.ManageMessageResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 },
        };

        let url_ = baseUrl + "WebStoreWidget/GetContainerDetails/{cmsMappingId}/{widgetKey}/{typeOfMapping}/{localeId}";

        if (cmsMappingId === undefined || cmsMappingId === null)
            throw new Error("The parameter 'cmsMappingId' must be defined.");
        url_ = url_.replace("{cmsMappingId}", encodeURIComponent("" + cmsMappingId));
        if (widgetKey === undefined || widgetKey === null)
            throw new Error("The parameter 'widgetKey' must be defined.");
        url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
        if (typeOfMapping === undefined || typeOfMapping === null)
            throw new Error("The parameter 'typeOfMapping' must be defined.");
        url_ = url_.replace("{typeOfMapping}", encodeURIComponent("" + typeOfMapping));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return WebStoreWidget_processGetContainerDetails(_response);
     
        });
    }
   
   
  function WebStoreWidget_processGetContainerDetails(response: Response): Promise<MultifrontTypes.ManageMessageResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ManageMessageResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
        return throwException("Internal Server Error", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Retrive a publish product.
 * @param publishProductId The API endpoint is used to retrieve the Product Details for the requested Publish Product Id.
 * @param expand (optional) A collection of fields to expand in the response, allowing for additional related data to be included. To retrieve this data, portalId and localeId are mandatory filters.
 * @param filter (optional) A collection of filters to apply when retrieving the expanded publish product. localeId, portalId and catelogId can be used as filters, and these are applicable solely for the purpose of expanding related data.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in PublishProductResponse model.)
 */

export async function PublishProducts_publishedProductsByPublishProductId(
  publishProductId: number,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/published-products/{publishProductId}";

  url_ += buildEndpointQueryString({ expand, filter });

  if (publishProductId === undefined || publishProductId === null) throw new Error("The parameter 'publishProductId' must be defined.");
  url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processPublishedProductsByPublishProductId(_response);
  });
}

function PublishProducts_processPublishedProductsByPublishProductId(response: Response): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }

  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishProductsDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * List all publish products.
 * @param filter (optional) A collection of filters to apply when retrieving the publish product list.
 * @param sort (optional) Sorting determines whether the records are to be sorted in ascending or descending order.
 * @param pageIndex (optional) When the record count is high, utilizing pagination enables the retrieval of a specific range of records.
 * @param pageSize (optional) The number of items to be displayed per page in paginated within paginated results.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in publish products list response model.)
 */

export async function PublishProducts_publishedProducts(
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.PublishProductsListResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/published-products";

  url_ += buildEndpointQueryString({ filter, sort, pageIndex, pageSize });

  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processPublishedProducts(_response);
  });
}

function PublishProducts_processPublishedProducts(response: Response): Promise<MultifrontTypes.PublishProductsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishProductsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * List all active publish product.
 * @param productIds The API endpoint is used to retrieve the Product Details for the requested Publish Product Id.
 * @param catalogId The catalog id associated with the product.
 * @param localeId The locale id associated with the product.
 * @param versionId (optional) The version id associated with the product.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Recently view products response model.)
 */

export async function PublishProducts_activeProductsByProductIds(
  productIds: string,
  catalogId: number,
  localeId: number,
  versionId: number | undefined
): Promise<MultifrontTypes.RecentViewProductsResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/publish-products/{productIds}/active-products";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogId=" + encodeURIComponent("" + catalogId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeId=" + encodeURIComponent("" + localeId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "versionId=" + encodeURIComponent("" + versionId);

  if (productIds === undefined || productIds === null) throw new Error("The parameter 'productIds' must be defined.");
  url_ = url_.replace("{productIds}", encodeURIComponent("" + productIds));
  if (catalogId === undefined || catalogId === null) throw new Error("The parameter 'catalogId' must be defined and cannot be null.");
  else if (localeId === undefined || localeId === null) throw new Error("The parameter 'localeId' must be defined and cannot be null.");
  else if (versionId === null) throw new Error("The parameter 'versionId' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processActiveProductsByProductIds(_response);
  });
}

function PublishProducts_processActiveProductsByProductIds(response: Response): Promise<MultifrontTypes.RecentViewProductsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.RecentViewProductsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Submits a stock notification request.
 * @param body (optional) The stock notification request model.
 * @return Success(Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function PublishProducts_stockRequest(body: Models.StockNotificationRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/publish-products/stock-request";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processStockRequest(_response);
  });
}

function PublishProducts_processStockRequest(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieves the inventory count for a specified product SKU.
 * @param productSku The SKU of the product for which inventory Details is requested.
 * @param cookieMappingId (optional) The CookieMappingId of the product inventory.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Recently view products response model.)
 */

export async function PublishProducts_inventoryCountByProductSku(
  productSku: string,
  cookieMappingId: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.ProductsInventoriesResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/publish-products/{productSku}/inventory-count";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "cookieMappingId=" + encodeURIComponent("" + cookieMappingId);

  if (productSku === undefined || productSku === null) throw new Error("The parameter 'productSku' must be defined.");
  url_ = url_.replace("{productSku}", encodeURIComponent("" + productSku));
  if (cookieMappingId === null) throw new Error("The parameter 'cookieMappingId' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processInventoryCountByProductSku(_response);
  });
}

function PublishProducts_processInventoryCountByProductSku(response: Response): Promise<MultifrontTypes.ProductsInventoriesResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ProductsInventoriesResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get Product inventory detail.
 * @param publishProductId The Id of the product for which inventory Details is requested.
 * @param catalogCode The code of the catalog. catalogCode is required field.
 * @param localeCode The code to get the localeId. localeCode is required field.
 * @param storeCode The code to get the portalId. storeCode is required field.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Product inventory details response model.)
 */

export async function PublishProducts_inventoryByPublishProductId(
  publishProductId: number,
  catalogCode: string,
  localeCode: string,
  storeCode: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.ProductInventoryDetailsResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/publish-products/{publishProductId}/inventory";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "storeCode=" + encodeURIComponent("" + storeCode);

  if (publishProductId === undefined || publishProductId === null) throw new Error("The parameter 'publishProductId' must be defined.");
  url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processInventoryByPublishProductId(_response);
  });
}

function PublishProducts_processInventoryByPublishProductId(response: Response): Promise<MultifrontTypes.ProductInventoryDetailsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ProductInventoryDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get product attributes by product id.
 * @param productId Product id.
 * @param localeCode (optional) The code is related to the locale.
 * @param selectedCode (optional) The code that might be related to the locale.
 * @param selectedValue (optional) The value that might be related to the selected code.
 * @param selectedAttributes (optional) Additional attributes related to the locale, stored as key-value pairs.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Recently view products response model.)
 */

export async function PublishProducts_attributesByProductId(
  productId: number,
  catalogCode: string,
  localeCode: string | undefined,
  selectedCode: string | undefined,
  selectedValue: string | undefined,
  selectedAttributes: { [key: string]: string } | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.ConfigurableAttributeListResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/published-products/{productId}/attributes";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "SelectedCode=" + encodeURIComponent("" + selectedCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "SelectedValue=" + encodeURIComponent("" + selectedValue);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "SelectedAttributes=" + encodeURIComponent("" + selectedAttributes);

  if (productId === undefined || productId === null) throw new Error("The parameter 'productId' must be defined.");
  url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (selectedCode === null) throw new Error("The parameter 'selectedCode' cannot be null.");
  if (selectedValue === null) throw new Error("The parameter 'selectedValue' cannot be null.");
  if (selectedAttributes === null) throw new Error("The parameter 'selectedAttributes' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processAttributesByProductId(_response);
  });
}

function PublishProducts_processAttributesByProductId(response: Response): Promise<MultifrontTypes.ConfigurableAttributeListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ConfigurableAttributeListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Associated configurable product variants.
 * @param additionalAttribute (optional) Additional attributes to be included in the response.
 * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function PublishProducts_configurableVariantsByPublishProductId(
  publishProductId: number,
  additionalAttribute: string | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.ConfigurableProductVariantsListResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/publish-products/{publishProductId}/configurable-variants";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "additionalAttribute=" + encodeURIComponent("" + additionalAttribute);

  if (publishProductId === undefined || publishProductId === null) throw new Error("The parameter 'publishProductId' must be defined.");
  url_ = url_.replace("{publishProductId}", encodeURIComponent("" + publishProductId));
  if (additionalAttribute === null) throw new Error("The parameter 'additionalAttribute' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processConfigurableVariantsByPublishProductId(_response);
  });
}

function PublishProducts_processConfigurableVariantsByPublishProductId(response: Response): Promise<MultifrontTypes.ConfigurableProductVariantsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ConfigurableProductVariantsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get product by product sku.
 * @param productSKU The product SKU.
 * @param parentProductId (optional) The ID of the parent product.
 * @param parentProductSKU (optional) The SKU (Stock Keeping Unit) of the parent product.
 * @param znodeCatalogId The ID of the catalog. This field is required. The value must be a positive integer.
 * @param localeCode The code of the locale. This field is required.
 * @param storeCode (optional) The code of the portal. To retrieve the image path, the StoreCode is required.
 * @param expand (optional) A collection of fields to expand in the response, allowing for additional related data to be included. The fields Seo, Pricing, Promotions, ProductReviews, and AddOns can be used as expands. To retrieve this data, LocaleCode and StoreCode are mandatory parameters.
 * @return Indicates that the request is successfully executed and the response body contains the requested data.
 */

export async function PublishProducts_skuByProductSKU(
  productSKU: string,
  parentProductId: number | undefined,
  parentProductSKU: string | undefined,
  znodeCatalogId: number,
  localeCode: string,
  storeCode: string | undefined,
  expand: string[] | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/published-products/sku/{productSKU}";

  url_ += buildEndpointQueryString({ expand });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "ParentProductId=" + encodeURIComponent("" + parentProductId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "ParentProductSKU=" + encodeURIComponent("" + parentProductSKU);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "ZnodeCatalogId=" + encodeURIComponent("" + znodeCatalogId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  if (productSKU === undefined || productSKU === null) throw new Error("The parameter 'productSKU' must be defined.");
  url_ = url_.replace("{productSKU}", encodeURIComponent("" + productSKU));
  if (parentProductId === null) throw new Error("The parameter 'parentProductId' cannot be null.");
  if (parentProductSKU === null) throw new Error("The parameter 'parentProductSKU' cannot be null.");
  if (znodeCatalogId === undefined || znodeCatalogId === null) throw new Error("The parameter 'znodeCatalogId' must be defined and cannot be null.");
  else if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processSkuByProductSKU(_response);
  });
}

function PublishProducts_processSkuByProductSKU(response: Response): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishProductsDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param catalogCode (optional)
 * @param localeCode (optional)
 * @param filter (optional)
 * @return OK
 */

export async function PublishProducts_groupProducts(
  catalogCode: string | undefined,
  localeCode: string | undefined,
  filter: FilterTuple[] | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/published-products/GroupProducts";

  url_ += buildEndpointQueryString({ filter });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  if (catalogCode === null) throw new Error("The parameter 'catalogCode' cannot be null.");
  if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processGroupProducts(_response);
  });
}

function PublishProducts_processGroupProducts(response: Response): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishProductsDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function appendQueryParams(url: string, data: { [key: string]: string } | undefined): string {
  if (!data) return url; // If no data is provided, return the original URL.
  const queryParams = Object.entries(data)
    .map(([key, value]) => {
      // Format the key as SelectedAttributes[<key>]
      const encodedKey = encodeURIComponent(key);
      const encodedValue = encodeURIComponent(value);
      return `SelectedAttributes[${encodedKey}]=${encodedValue}`;
    })
    .join("&"); // Join all parameters with '&'

  // Check if there are existing query parameters in the URL
  if (url.includes("?")) {
    // If the URL already has query parameters, append the new ones with '&'
    return `${url}&${queryParams}`;
  } else {
    // Otherwise, add a '?' and then the query parameters
    return `${url}?${queryParams}`;
  }
}

/**
 * Get Configurable product.
 * @param parentProductSKU Configurable product SKU.
 * @param catalogCode Associated catalog code.
 * @param storeCode Associated store code.
 * @param localeCode (optional) Locale code.
 * @param selectedAttributes (optional) Selected attribute code for configurable product variants.
 * @param expand (optional)
 * @return OK
 */

export async function PublishProducts_configurableProductsByParentProductSKU(
  parentProductSKU: string,
  catalogCode: string,
  storeCode: string,
  localeCode: string | undefined,
  selectedAttributes: { [key: string]: string } | undefined,
  expand: string[] | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/published-products/{parentProductSKU}/configurable-products";

  url_ += buildEndpointQueryString({ expand });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "storeCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  url_ = appendQueryParams(url_, selectedAttributes);

  if (parentProductSKU === undefined || parentProductSKU === null) throw new Error("The parameter 'parentProductSKU' must be defined.");
  url_ = url_.replace("{parentProductSKU}", encodeURIComponent("" + parentProductSKU));
  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (selectedAttributes === null) throw new Error("The parameter 'selectedAttributes' cannot be null.");
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processConfigurableProductsByParentProductSKU(_response);
  });
}

function PublishProducts_processConfigurableProductsByParentProductSKU(response: Response): Promise<MultifrontTypes.PublishProductsDetailsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishProductsDetailsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get list of valid products by SKUs.
 * @param catalogCode Associated catalog code.
 * @param storeCode Associated store code.
 * @param localeCode (optional) Locale code.
 * @param body (optional)
 * @return Indicates that the request is successfully executed and the response body contains the requested data.
 */

export async function PublishProducts_validateProduct(
  catalogCode: string,
  storeCode: string,
  localeCode: string | undefined,
  body: Models.ValidateSKUsRequest | undefined
): Promise<MultifrontTypes.ValidatedProductListResponse> {
  let url_ = baseUrl + "v2/published-products/validate-product";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "storeCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
    cache: "no-store",
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processValidateProduct(_response);
  });
}

function PublishProducts_processValidateProduct(response: Response): Promise<MultifrontTypes.ValidatedProductListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ValidatedProductListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

/**
 * Retrieves a list of published products based on the provided parameters.
 * @param productSKUs The SKU of the product to filter the results by.
 * @param localeCode (optional) The locale code associated with the product.
 * @param catalogCode (optional) The catalog code to filter the results by.
 * @param storeCode The store code to filter the results by. This parameter is required.
 * @param expand (optional) A collection of fields to expand in the response.
 * @param filter (optional) A collection of filters to apply to the product list.
 * @param sort (optional) A collection of sorting parameters to apply to the product list.
 * @return OK
 */
export async function PublishProducts_compareProducts(
  productSKUs: string,
  localeCode: string | undefined,
  catalogCode: string | undefined,
  storeCode: string,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined
): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
  };
  options_ = addCacheOption(filter ?? [], options_);

  let url_ = baseUrl + "v2/published-products/{productSKUs}/compare-products";
  url_ += buildEndpointQueryString({ localeCode, catalogCode, storeCode, expand, filter, sort });
  if (productSKUs === undefined || productSKUs === null) throw new Error("The parameter 'productSKUs' must be defined.");
  url_ = url_.replace("{productSKUs}", encodeURIComponent("" + productSKUs));
  if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (catalogCode === null) throw new Error("The parameter 'catalogCode' cannot be null.");
  if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return PublishProducts_processCompareProducts(_response);
  });
}

function PublishProducts_processCompareProducts(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PublishCatalogProductListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Retrieve the data for a link widget.
 * @param cMSMappingId An identifier for the mapping of the widget.
 * @param localeCode (optional) An identifier for the locale associated with the widget.
 * @param storeCode The portal identifier associated with the CMS mapping.
 * @param typeOfMapping The type of mapping associated with the widget.
 * @param profileId (optional) Retrieves a specific profile based on the provided profile ID.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in WebStoreLinkWidgetsResponse model.)
 */

export async function WebStoreWidgets_linkWidgetsByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  localeCode: string | undefined,
  storeCode: string,
  typeOfMapping: string,
  profileId: string | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WebStoreLinkWidgetsResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/link-widgets";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "ProfileId=" + encodeURIComponent("" + profileId);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else if (profileId === null) throw new Error("The parameter 'profileId' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");
  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processLinkWidgetsByWidgetKey(_response);
  });
}

function WebStoreWidgets_processLinkWidgetsByWidgetKey(response: Response): Promise<MultifrontTypes.WebStoreLinkWidgetsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WebStoreLinkWidgetsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get container data.
 * @param widgetKey The widget key used in the CMS mapping.
 * @param cMSMappingId An identifier for the mapping of the widget
 * @param localeCode (optional) An identifier for the locale associated with the widget
 * @param typeOfMapping The type of mapping associated with the widget
 * @return Success(Indicates that the request is successfully executed and the response body return the data in WebStoreLinkWidgetsResponse model.)
 */

export async function WebStoreWidgets_containersByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  localeCode: string | undefined,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WidgetMessageResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/containers";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");
  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processContainersByWidgetKey(_response);
  });
}

function WebStoreWidgets_processContainersByWidgetKey(response: Response): Promise<MultifrontTypes.WidgetMessageResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WidgetMessageResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieve the data for a slider widget.
 * @param widgetKey The widget key used in the CMS mapping.
 * @param cMSMappingId The CMS mapping identifier, which is required.
 * @param localeCode (optional) The locale identifier associated with the CMS mapping.
 * @param typeOfMapping The type of mapping in the CMS, which is required.
 * @param storeCode (optional) The portal identifier associated with the CMS mapping.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in WidgetsSlidersResponse model.)
 */

export async function WebStoreWidgets_slidersByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  localeCode: string | undefined,
  typeOfMapping: string,
  storeCode: string | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WidgetsSlidersResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/sliders";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");
  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processSlidersByWidgetKey(_response);
  });
}

function WebStoreWidgets_processSlidersByWidgetKey(response: Response): Promise<MultifrontTypes.WidgetsSlidersResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WidgetsSlidersResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get product list widget data.
 * @param widgetKey The widget key used in the CMS mapping.
 * @param cMSMappingId The CMS mapping identifier.
 * @param localeCode The locale identifier associated with the CMS mapping.
 * @param storeCode (optional) The portal identifier associated with the CMS mapping.
 * @param widgetCode (optional) The code for the widget.
 * @param typeOfMapping The type of mapping in the CMS.
 * @param publishCatalogId The publish catalog identifier.
 * @param expand (optional) Collection of entities to expand in the response (e.g., attributes, images). Optional.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in WebStoreWidgetProductsListResponse model.)
 */
export async function WebStoreWidgets_products(
  widgetKey: string,
  cMSMappingId: number,
  localeCode: string,
  storeCode: string | undefined,
  widgetCode: string | undefined,
  typeOfMapping: string,
  publishCatalogId: number,
  expand: string[] | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<any> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);
  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/products";
  url_ += buildEndpointQueryString({ cMSMappingId, localeCode, storeCode, widgetCode, typeOfMapping, publishCatalogId, expand });
  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  if (widgetCode === null) throw new Error("The parameter 'widgetCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else if (publishCatalogId === undefined || publishCatalogId === null) throw new Error("The parameter 'publishCatalogId' must be defined and cannot be null.");
  else if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processProducts(_response);
  });
}

function WebStoreWidgets_processProducts(response: Response): Promise<any> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WidgetProductsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function WebStoreWidgets_processProductsByWidgetKey(response: Response): Promise<MultifrontTypes.WidgetProductsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WidgetProductsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * @param cMSMappingId The CMS mapping identifier, which is required.
 * @param storeCode (optional) The portal identifier. StoreCode is used to get PublishCategoryModel.
 * @param catalogCode (optional) The CatalogCode associated with the catgeory widget.
 * @param localeCode (optional) The locale identifier. LocaleCode is used to get PublishCategoryModel.
 * @param typeOfMapping The type of mapping in the CMS, which is required.
 * @return OK
 */

export async function WebStoreWidgets_linkedCategoryByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  storeCode: string | undefined,
  catalogCode: string | undefined,
  localeCode: string | undefined,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WebStoreWidgetCategoryResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/linked-category";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CatalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  if (catalogCode === null) throw new Error("The parameter 'catalogCode' cannot be null.");
  if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processLinkedCategoryByWidgetKey(_response);
  });
}

function WebStoreWidgets_processLinkedCategoryByWidgetKey(response: Response): Promise<MultifrontTypes.WebStoreWidgetCategoryResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WebStoreWidgetCategoryResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get media widget details.
 * @param widgetKey The widget key used in the CMS mapping.
 * @param cMSMappingId The unique identifier for the CMS mapping.
 * @param typeOfMapping The type of mapping used.
 * @return Success (Indicates that the request is successfully executed and the response body return the data in MediaWidgetResponse model.)
 */

export async function WebStoreWidgets_mediaWidgetByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.MediaWidgetConfigurationResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/media-widget";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processMediaWidgetByWidgetKey(_response);
  });
}

function WebStoreWidgets_processMediaWidgetByWidgetKey(response: Response): Promise<MultifrontTypes.MediaWidgetConfigurationResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.MediaWidgetConfigurationResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieve the data for a tag manager widget.
 * @param widgetKey Unique key for a widget.
 * @param cMSMappingId An identifier for the mapping of the widget
 * @param localeCode (optional) An identifier for the locale associated with the widget
 * @param typeOfMapping The type of mapping associated with the widget
 * @return Success(Indicates that the request is successfully executed and the response body return the data in WebStoreLinkWidgetsResponse model.)
 */

export async function WebStoreWidgets_textWidgetsByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  localeCode: string | undefined,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.TextWidgetReponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/text-widgets";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processTextWidgetsByWidgetKey(_response);
  });
}

function WebStoreWidgets_processTextWidgetsByWidgetKey(response: Response): Promise<MultifrontTypes.TextWidgetReponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.TextWidgetReponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

    /**
         * Gets linked product list.
         * @param sku The SKU of the product for which linked products are requested.
         * @param localeCode (optional) The locale identifier.
         * @param catalogCode The publish catalog identifier. This is a required field.
         * @param storeCode (optional) The portal code.
         * @param expand (optional) Collection of fields to be expanded in the response.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in WebStoreLinkProductResponse model.)
         */
            
    export async function WebStoreWidgets_linkProductsBySku(
      sku: string,
      localeCode: string | undefined,
      catalogCode: string,
      storeCode: string | undefined,
      expand: string[] | undefined,
      cacheInvalidator?: FilterTuple[] | undefined
    ): Promise<MultifrontTypes.WebStoreLinkProductResponse> {
      let options_: RequestInit = {
        method: "GET",
        cache: "no-store",
        headers: await getHeaders("GET", String(baseUrl)),
        next: { revalidate: 0 },
      };
      options_ = addCacheOption(cacheInvalidator ?? [], options_);

      let url_ = baseUrl + "v2/webstore-widgets/{sku}/link-products";

      url_ += buildEndpointQueryString({ expand });

      url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

      url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CatalogCode=" + encodeURIComponent("" + catalogCode);

      url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

      if (sku === undefined || sku === null) throw new Error("The parameter 'sku' must be defined.");
      url_ = url_.replace("{sku}", encodeURIComponent("" + sku));
      if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
      if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
      else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
      if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
      url_ = url_.replace(/[?&]$/, "");

      return fetch(url_, options_).then((_response: Response) => {
        return WebStoreWidgets_processLinkProductsBySku(_response);
      });
    }
 
 
function WebStoreWidgets_processLinkProductsBySku(response: Response): Promise<MultifrontTypes.WebStoreLinkProductResponse> {
    const status = response.status;
     let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
  if (status === 200) {
      return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.WebStoreLinkProductResponse;
      return result200;
      });
  } else if (status === 204) {
      return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
      return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
      });
  } else if (status === 400) {
      return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
      });
  } else if (status === 500) {
      return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
      });
  } else if (status === 404) {
      return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
      return throwException("Not Found(Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
      });
  } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
  }
  return Promise.resolve<any>(null as any);
     
    
  }



/**
 * Retrieve form configuration data.
 * @param mappingId The CMS mapping identifier.
 * @param localeCode (optional) Locale code.
 * @return Indicates that the request is successfully executed and the response body return the data in WebstoreWidgetFormResponse model.
 */

export async function WebStoreWidgets_formConfigurationByMappingId(mappingId: number, localeCode: string | undefined): Promise<MultifrontTypes.WebstoreWidgetFormResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/FormConfiguration/{mappingId}";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  if (mappingId === undefined || mappingId === null) throw new Error("The parameter 'mappingId' must be defined.");
  url_ = url_.replace("{mappingId}", encodeURIComponent("" + mappingId));
  if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processFormConfigurationByMappingId(_response);
  });
}

function WebStoreWidgets_processFormConfigurationByMappingId(response: Response): Promise<MultifrontTypes.WebstoreWidgetFormResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WebstoreWidgetFormResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * a brand list widget data.
 * @param widgetKey Unique key for a widget.
 * @param cMSMappingId An identifier for the mapping of the widget.
 * @param storeCode (optional) An identifier for the locale associated with the widget.
 * @param localeCode (optional) The locale identifier.
 * @param typeOfMapping The type of mapping in the CMS, which is required.
 * @return Indicates that the request is successfully executed and the response body contains the requested data.
 */

export async function WebStoreWidgets_brandsByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  storeCode: string | undefined,
  localeCode: string | undefined,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WebStoreWidgetBrandsListResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/WebStoreWidgets/{widgetKey}/brands";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processBrandsByWidgetKey(_response);
  });
}

function WebStoreWidgets_processBrandsByWidgetKey(response: Response): Promise<MultifrontTypes.WebStoreWidgetBrandsListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WebStoreWidgetBrandsListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * List all search result for the widget keyword.
 * @param cMSMappingId (optional) The unique identifier for the CMS mapping.
 * @param widgetKey The key for the widget.
 * @param typeOfMapping The type of mapping.
 * @param localeCode The unique identifier for the locale.
 * @param catalogCode The unique identifier for the catalog.
 * @param storeCode The unique identifier for the portal.
 * @param isFacetList (optional) Indicates if the list is a facet list.
 * @param pageIndex (optional) The index of the page.
 * @param pageSize (optional) The size of each page.
 * @return Success (Indicates that the request is successfully executed and the response body return the data in WebstoreSearchWidgetResponse model.)
 */

export async function WebStoreWidgets_searchWidgetData(
  cMSMappingId: number | undefined,
  widgetKey: string,
  typeOfMapping: string,
  localeCode: string,
  catalogCode: string,
  storeCode: string,
  isFacetList: boolean | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.WebstoreSearchWidgetResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/search-widget-data";

  url_ += buildEndpointQueryString({ pageIndex, pageSize });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "WidgetKey=" + encodeURIComponent("" + widgetKey);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CatalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "IsFacetList=" + encodeURIComponent("" + isFacetList);

  if (cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' cannot be null.");
  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined and cannot be null.");
  else if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (isFacetList === null) throw new Error("The parameter 'isFacetList' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processSearchWidgetData(_response);
  });
}

function WebStoreWidgets_processSearchWidgetData(response: Response): Promise<MultifrontTypes.WebstoreSearchWidgetResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.WebstoreSearchWidgetResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieve a slider data.
 * @param widgetKey Unique key for a widget.
 * @param cMSMappingId An identifier for the mapping of the widget.
 * @param localeId An identifier for the locale associated with the widget.
 * @param portalId The type of mapping associated with the widget.
 * @param typeOfMapping The type of mapping associated with the widget.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in SliderMessageResponse model.)
 */

export async function WebStoreWidgets_sliderWidgetsByWidgetKey(
  widgetKey: string,
  cMSMappingId: number,
  localeId: number,
  portalId: number,
  typeOfMapping: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.SliderMessageResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/webstore-widgets/{widgetKey}/slider-widgets";

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CMSMappingId=" + encodeURIComponent("" + cMSMappingId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleId=" + encodeURIComponent("" + localeId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "PortalId=" + encodeURIComponent("" + portalId);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "TypeOfMapping=" + encodeURIComponent("" + typeOfMapping);

  if (widgetKey === undefined || widgetKey === null) throw new Error("The parameter 'widgetKey' must be defined.");
  url_ = url_.replace("{widgetKey}", encodeURIComponent("" + widgetKey));
  if (cMSMappingId === undefined || cMSMappingId === null) throw new Error("The parameter 'cMSMappingId' must be defined and cannot be null.");
  else if (localeId === undefined || localeId === null) throw new Error("The parameter 'localeId' must be defined and cannot be null.");
  else if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined and cannot be null.");
  else if (typeOfMapping === undefined || typeOfMapping === null) throw new Error("The parameter 'typeOfMapping' must be defined and cannot be null.");
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return WebStoreWidgets_processSliderWidgetsByWidgetKey(_response);
  });
}

function WebStoreWidgets_processSliderWidgetsByWidgetKey(response: Response): Promise<MultifrontTypes.SliderMessageResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SliderMessageResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Retrieve an user detail.
 * @param userId The ID of the user.
 * @param storeCode The Code of the store.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_usersGetByUserId(userId: number, storeCode: string): Promise<MultifrontTypes.UserDetailResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/users/{userId}/{storeCode}";

  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined.");
  url_ = url_.replace("{storeCode}", encodeURIComponent("" + storeCode));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUsersGetByUserId(_response);
  });
}

function Users_processUsersGetByUserId(response: Response): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Changes the user's password.
 * @param body (optional) The user request model containing the portal ID and login user details.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserPasswordResponse model.)
 */

export async function Users_changePassword(body: Models.ChangePasswordRequestModel | undefined): Promise<MultifrontTypes.UserPasswordResponse> {
  let url_ = baseUrl + "v2/users/change-password";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processChangePassword(_response);
  });
}

function Users_processChangePassword(response: Response): Promise<MultifrontTypes.UserPasswordResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserPasswordResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Handles user login requests.
 * @param body (optional) The login request model containing user credentials.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_login(body: Models.LoginRequestModel | undefined): Promise<MultifrontTypes.UserLoginResponse> {
  let url_ = baseUrl + "v2/users/login";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processLogin(_response);
  });
}

function Users_processLogin(response: Response): Promise<MultifrontTypes.UserLoginResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserLoginResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Handles the forgot password request.
 * @param body (optional) The forgot password request model.
 * @return Success: The request was successfully executed, and the response body contains the data in the Znode.Engine.Customer.Model.UserPasswordResponse model.
 */

export async function Users_forgotPassword(body: Models.UserForgetPasswordRequest | undefined): Promise<MultifrontTypes.UserPasswordResponse> {
  let url_ = baseUrl + "v2/users/forgot-password";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };
  return fetch(url_, options_).then((_response: Response) => {
    return Users_processForgotPassword(_response);
  });
}

function Users_processForgotPassword(response: Response): Promise<MultifrontTypes.UserPasswordResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserPasswordResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content: The request was successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request: The request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error: An error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found: The server could not find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * list of users by account id.
 * @param loggedUserAccountId The ID of the user account.
 * @param filter (optional) The filter collection.
 * @param sort (optional) The sort collection.
 * @param pageIndex (optional) The page index.
 * @param pageSize (optional) The page size.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Users list response object.)
 */

export async function Users_userAccountsByLoggedUserAccountId(
  loggedUserAccountId: number,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.UsersListResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/users/{loggedUserAccountId}/user-accounts";

  url_ += buildEndpointQueryString({ filter, sort, pageIndex, pageSize });

  if (loggedUserAccountId === undefined || loggedUserAccountId === null)
    throw new Error("The parameter 'loggedUserAccountId' must be defined.");
  url_ = url_.replace(
    "{loggedUserAccountId}",
    encodeURIComponent("" + loggedUserAccountId)
  );
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUserAccountsByLoggedUserAccountId(_response);
  });
}

function Users_processUserAccountsByLoggedUserAccountId(
  response: Response
): Promise<MultifrontTypes.UsersListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then(_responseText => {
      let result200: any = null;
      result200 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.UsersListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then(_responseText => {
      let result204: any = null;
      result204 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 500) {
    return response.text().then(_responseText => {
      let result500: any = null;
      result500 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Server Error(Indicates that an error occurred on the server.)",
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status === 404) {
    return response.text().then(_responseText => {
      let result404: any = null;
      result404 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "This status code indicates that the server cannot find the requested resource.)",
        status,
        _responseText,
        _headers,
        result404
      );
    });
  } else if (status === 400) {
    return response.text().then(_responseText => {
      let result400: any = null;
      result400 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Bad Request(The request contain invalid Data.)",
        status,
        _responseText,
        _headers,
        result400
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then(_responseText => {
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Signs up a user for the newsletter.
 * @param body (optional) The request model containing the user's email.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Users list response object.)
 */

export async function Users_signUpForNewsletter(body: Models.NewsLetterSignUpRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/users/sign-up-for-newsletter";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processSignUpForNewsletter(_response);
  });
}

function Users_processSignUpForNewsletter(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Create social login.
 * @param body (optional) The request model containing social login details.
 * @return OK
 */

export async function Users_socialLogin(body: Models.SocialLoginRequest | undefined): Promise<MultifrontTypes.UserDetailResponse> {
  let url_ = baseUrl + "v2/users/social-login";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processSocialLogin(_response);
  });
}

function Users_processSocialLogin(response: Response): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content - Indicates that the request is successfully executed, but the response body does not contain any data.",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error - Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request - The request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieves the user details for a specific username and storeCode.
 * @param username The username of the user. Can only contain alphanumeric characters and underscores.
 * @param storeCode unique code or identifier for a store. mostely is used to differentiate between multiple store locations or portals in the system.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_usersByUsername(
  username: string,
  storeCode: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.UserDetailResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/users/{username}";

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "storeCode=" +
    encodeURIComponent("" + storeCode);

  if (username === undefined || username === null)
    throw new Error("The parameter 'username' must be defined.");
  url_ = url_.replace("{username}", encodeURIComponent("" + username));
  if (storeCode === undefined || storeCode === null)
    throw new Error(
      "The parameter 'storeCode' must be defined and cannot be null."
    );
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUsersByUsername(_response);
  });
}

function Users_processUsersByUsername(
  response: Response
): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then(_responseText => {
      let result200: any = null;
      result200 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then(_responseText => {
      let result204: any = null;
      result204 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then(_responseText => {
      let result400: any = null;
      result400 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Bad Request(The request contain invalid Data.)",
        status,
        _responseText,
        _headers,
        result400
      );
    });
  } else if (status === 404) {
    return response.text().then(_responseText => {
      let result404: any = null;
      result404 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "This status code indicates that the server cannot find the requested resource.)",
        status,
        _responseText,
        _headers,
        result404
      );
    });
  } else if (status === 500) {
    return response.text().then(_responseText => {
      let result500: any = null;
      result500 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Server Error(Indicates that an error occurred on the server.)",
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then(_responseText => {
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieve a user account data
 * @param username The username of the user. Can only contain alphanumeric characters and underscores.
 * @param storeCode unique code or identifier for a store. mostely is used to differentiate between multiple store locations or portals in the system.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_userAccountDataByUsername(
  username: string,
  storeCode: string,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.UserDetailResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/users/{username}/user-account-data";

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "storeCode=" +
    encodeURIComponent("" + storeCode);

  if (username === undefined || username === null)
    throw new Error("The parameter 'username' must be defined.");
  url_ = url_.replace("{username}", encodeURIComponent("" + username));
  if (storeCode === undefined || storeCode === null)
    throw new Error(
      "The parameter 'storeCode' must be defined and cannot be null."
    );
  else url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUserAccountDataByUsername(_response);
  });
}

function Users_processUserAccountDataByUsername(
  response: Response
): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then(_responseText => {
      let result200: any = null;
      result200 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then(_responseText => {
      let result204: any = null;
      result204 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 500) {
    return response.text().then(_responseText => {
      let result500: any = null;
      result500 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Server Error(Indicates that an error occurred on the server.)",
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status === 404) {
    return response.text().then(_responseText => {
      let result404: any = null;
      result404 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "This status code indicates that the server cannot find the requested resource.)",
        status,
        _responseText,
        _headers,
        result404
      );
    });
  } else if (status === 400) {
    return response.text().then(_responseText => {
      let result400: any = null;
      result400 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Bad Request(The request contain invalid Data.)",
        status,
        _responseText,
        _headers,
        result400
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then(_responseText => {
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Enables or disables a user account.
 * @param userId The ID of the user to enable or disable.
 * @param body (optional) A boolean value indicating whether to disable or enable the user account.
 * @return OK
 */

export async function Users_accountStatus(userId: number, body: Models.UpdateUserAccountStatusRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/users/{userId}/account-status";

  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processAccountStatus(_response);
  });
}

function Users_processAccountStatus(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Retrieves a list of social login providers.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_loginProviders(): Promise<MultifrontTypes.SocialProviderResponseModel> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/login-providers";

  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processLoginProviders(_response);
  });
}

function Users_processLoginProviders(response: Response): Promise<MultifrontTypes.SocialProviderResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SocialProviderResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Creates a new customer account.
 * @param body (optional) The user creation request model.
 * @return OK
 */

export async function Users_usersPost(body: Models.CreateUserRequest | undefined): Promise<MultifrontTypes.UserDetailResponse> {
  let url_ = baseUrl + "v2/users";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUsersPost(_response);
  });
}

function Users_processUsersPost(response: Response): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (The request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 409) {
    return response.text().then((_responseText) => {
      let result409: any = null;
      result409 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Conflict", status, _responseText, _headers, result409);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates an existing customer account.
 * @param userName Username of the account to be updated.
 * @param body (optional) The user update request model.
 * @return OK (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Users_usersPut(userName: string, body: Models.UpdateUserRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/users/{userName}";

  if (userName === undefined || userName === null) throw new Error("The parameter 'userName' must be defined.");
  url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUsersPut(_response);
  });
}

function Users_processUsersPut(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (The request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Bulk reset password.
 * @param userIds User id to reset the pasword.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_resetPasswordBulk(userIds: string): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/reset-password-bulk/{userIds}";

  if (userIds === undefined || userIds === null) throw new Error("The parameter 'userIds' must be defined.");
  url_ = url_.replace("{userIds}", encodeURIComponent("" + userIds));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processResetPasswordBulk(_response);
  });
}

function Users_processResetPasswordBulk(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Updates an existing user admin account.
 * @param userId It is required parameter
 * @param isWebstoreUser Web store user status for getting the reponse it should be true
 * @param body (optional) Account Model.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_accountData(
  userId: number,
  isWebstoreUser: boolean,
  body: Models.UpdateUserAccountDataRequest | undefined
): Promise<MultifrontTypes.UserDetailResponse> {
  let url_ = baseUrl + "v2/users/{userId}/{isWebstoreUser}/account-data";

  if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
  url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
  if (isWebstoreUser === undefined || isWebstoreUser === null) throw new Error("The parameter 'isWebstoreUser' must be defined.");
  url_ = url_.replace("{isWebstoreUser}", encodeURIComponent("" + isWebstoreUser));
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processAccountData(_response);
  });
}

function Users_processAccountData(response: Response): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Verify Reset Password Link Status.
 * @param body (optional) The user request model containing the portal ID and login user details.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in UserDetailResponse model.)
 */

export async function Users_verifyResetPasswordLink(body: Models.ResetPasswordLinkRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/users/verify-reset-password-link";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processVerifyResetPasswordLink(_response);
  });
}

function Users_processVerifyResetPasswordLink(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Validates the given CSR token.
 * @param body (optional) The CSR token to validate.
 * @return Indicates that the request is successfully executed and the response body contains the requested data.
 */

export async function Users_validateCsrToken(body: Models.ImpersonationRequestModel | undefined): Promise<MultifrontTypes.ImpersonationResponseModel> {
  let url_ = baseUrl + "v2/users/validate-csr-token";
  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);
  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return Users_processValidateCsrToken(_response);
  });
}

function Users_processValidateCsrToken(response: Response): Promise<MultifrontTypes.ImpersonationResponseModel> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ImpersonationResponseModel);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request is successfully executed, but the response body does not contain any data.", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that the request contains invalid data.", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Indicates that an error occurred on the server.", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

/**
 * Creates a new customer account.
 * @param body (optional) The user creation request model.
 * @return OK
 */

export async function Users_users(body: Models.CreateUserRequest | undefined): Promise<MultifrontTypes.UserDetailResponse> {
  let url_ = baseUrl + "v2/users";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",

    headers: await getHeaders("POST", String(baseUrl)),
  };
  return fetch(url_, options_).then((_response: Response) => {
    return Users_processUsers(_response);
  });
}

function Users_processUsers(response: Response): Promise<MultifrontTypes.UserDetailResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }

  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result200;
    });
  } else if (status === 201) {
    return response.text().then((_responseText) => {
      let result201: any = null;
      result201 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.UserDetailResponse);
      return result201;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (The request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 409) {
    return response.text().then((_responseText) => {
      let result409: any = null;
      result409 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Conflict", status, _responseText, _headers, result409);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found. The server cannot find the requested resource.", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

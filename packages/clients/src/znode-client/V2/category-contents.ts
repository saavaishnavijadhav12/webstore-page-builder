//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * List of category products.
 * @param categoryCode The identifier of the category.
 * @param catalogCode The catalog identifier, used to identify the specific catalog of products or categories.
 * @param localeCode (optional) The locale identifier, used to specify the language or region-specific settings..
 * @param storeCode (optional) The portal identifier, which specifies the portal (or site) from which the request is made.
 * @param additionalAttribute (optional) Additional attributes comma-separated string for the category content request to get the required additional attributes by attribute code.
 * @param refineBy (optional) Typically used for filtering products or categories based on specific attributes.
 * @param expand (optional) The sorting criteria(Expand Keys: facet,highlights).
 * @param filter (optional)
 * @param sort (optional) The sorting criteria.
 * @param pageIndex (optional) The index of the page.
 * @param pageSize (optional) The size of each page.
 * @return Success(Indicates that the request is successfully executed and the response body return the data in Category content model.)
 */

export async function CategoryContents_productsByCategoryCode(
  categoryCode: string,
  catalogCode: string,
  localeCode: string | undefined,
  storeCode: string | undefined,
  additionalAttribute: string | undefined,
  refineBy: string | undefined,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.CategoryContentResponse> {

  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/categories/{categoryCode}/products";

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "catalogCode=" +
    encodeURIComponent("" + catalogCode);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "localeCode=" +
    encodeURIComponent("" + localeCode);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "StoreCode=" +
    encodeURIComponent("" + storeCode);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "AdditionalAttribute=" +
    encodeURIComponent("" + additionalAttribute);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "RefineBy=" +
    encodeURIComponent("" + refineBy);

  if (categoryCode === undefined || categoryCode === null)
    throw new Error("The parameter 'categoryCode' must be defined.");
  url_ = url_.replace("{categoryCode}", encodeURIComponent("" + categoryCode));
  if (catalogCode === undefined || catalogCode === null)
    throw new Error(
      "The parameter 'catalogCode' must be defined and cannot be null."
    );
  else if (localeCode === null)
    throw new Error("The parameter 'localeCode' cannot be null.");
  if (storeCode === null)
    throw new Error("The parameter 'storeCode' cannot be null.");
  if (additionalAttribute === null)
    throw new Error("The parameter 'additionalAttribute' cannot be null.");
  if (refineBy === null)
    throw new Error("The parameter 'refineBy' cannot be null.");
  if (expand === null)
    throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null)
    throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null)
    throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return CategoryContents_processProductsByCategoryCode(_response);
  });
}

function CategoryContents_processProductsByCategoryCode(
  response: Response
): Promise<MultifrontTypes.CategoryContentResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then(_responseText => {
      let result200: any = null;
      result200 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.CategoryContentResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then(_responseText => {
      let result204: any = null;
      result204 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then(_responseText => {
      let result400: any = null;
      result400 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Bad Request(The request contain invalid Data.)",
        status,
        _responseText,
        _headers,
        result400
      );
    });
  } else if (status === 500) {
    return response.text().then(_responseText => {
      let result500: any = null;
      result500 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Server Error(Indicates that an error occurred on the server.)",
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then(_responseText => {
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

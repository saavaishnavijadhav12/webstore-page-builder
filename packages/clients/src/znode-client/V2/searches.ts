//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { addCacheOption, buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
 * Get SEO Url Details by Seo Url and storeCode.
 * @param seoUrl seo Url is a rquired parameter to get the SEO Url Details.
 * @param storeCode Store code is a rquired parameter to get the SEO Url Details.
 * @param localeCode (optional) Locale code is a optional parameter used to get the Category Id and Category Name.
 * @param catalogCode (optional) Catalog code is a optional parameter used to get the Category Id and Category Name.
 * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Searches_seoUrlsBySeoUrl(
  seoUrl: string,
  storeCode: string,
  localeCode: string | undefined,
  catalogCode: string | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.SEOUrlsResponse> {
  let options_: RequestInit = {
    method: "GET",
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };
  options_ = addCacheOption(cacheInvalidator ?? [], options_);

  let url_ = baseUrl + "v2/search/seo-urls/{seoUrl}";

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "storeCode=" +
    encodeURIComponent("" + storeCode);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "localeCode=" +
    encodeURIComponent("" + localeCode);

  url_ +=
    (url_.indexOf("?") === -1 ? "?" : "&") +
    "catalogCode=" +
    encodeURIComponent("" + catalogCode);

  if (seoUrl === undefined || seoUrl === null)
    throw new Error("The parameter 'seoUrl' must be defined.");
  url_ = url_.replace("{seoUrl}", encodeURIComponent("" + seoUrl));
  if (storeCode === undefined || storeCode === null)
    throw new Error(
      "The parameter 'storeCode' must be defined and cannot be null."
    );
  else if (localeCode === null)
    throw new Error("The parameter 'localeCode' cannot be null.");
  if (catalogCode === null)
    throw new Error("The parameter 'catalogCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Searches_processSeoUrlsBySeoUrl(_response);
  });
}

function Searches_processSeoUrlsBySeoUrl(
  response: Response
): Promise<MultifrontTypes.SEOUrlsResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then(_responseText => {
      let result200: any = null;
      result200 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.SEOUrlsResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then(_responseText => {
      let result204: any = null;
      result204 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then(_responseText => {
      let result400: any = null;
      result400 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Bad Request (The request contain invalid Data.)",
        status,
        _responseText,
        _headers,
        result400
      );
    });
  } else if (status === 500) {
    return response.text().then(_responseText => {
      let result500: any = null;
      result500 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Server Error (Indicates that an error occurred on the server.)",
        status,
        _responseText,
        _headers,
        result500
      );
    });
  } else if (status === 404) {
    return response.text().then(_responseText => {
      let result404: any = null;
      result404 =
        _responseText === ""
          ? null
          : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "Not Found (This status code indicates that the server cannot find the requested resource.)",
        status,
        _responseText,
        _headers,
        result404
      );
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then(_responseText => {
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get product details.
 * @param sKU The Stock Keeping Unit (SKU) of the product to retrieve details for. This is a required parameter.
 * @param catalogCode The code of the portal for which to retrieve product details. This is a required parameter and must be a positive integer.
 * @param localeCode The code of the locale for which to retrieve product details. This is a required parameter and must be a positive integer.
 * @param expand (optional) An optional parameter to specify related entities to include in the response.
 * @param filter (optional) An optional parameter to apply filters on the data.
 * @param sort (optional) An optional parameter to sort the data.
 * @param pageIndex (optional) An optional parameter to specify the index of the page to retrieve. Defaults to 0 if not specified.
 * @param pageSize (optional) An optional parameter to specify the number of items per page. Defaults to 10 if not specified.
 * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Searches_productsBySKU(
  sKU: string,
  catalogCode: string,
  localeCode: string,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.ProductSearchResponse> {
  let options_: RequestInit = {
    method: "GET",
    cache: "no-store",
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/search/products/{SKU}";

  url_ += buildEndpointQueryString({
    expand,
    filter,
    sort,
    pageIndex,
    pageSize,
  });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "catalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "localeCode=" + encodeURIComponent("" + localeCode);

  if (sKU === undefined || sKU === null) throw new Error("The parameter 'sKU' must be defined.");
  url_ = url_.replace("{SKU}", encodeURIComponent("" + sKU));
  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Searches_processProductsBySKU(_response);
  });
}

function Searches_processProductsBySKU(response: Response): Promise<MultifrontTypes.ProductSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ProductSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (The request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}
/**
 * Retrieves keyword search suggestions based on the provided search criteria.
 * @param keyword Represents the search keyword input by the user.
 * @param isAutocomplete (optional) Indicates if the search is for autocomplete suggestions.
 * @param storeCode Identifies the portal in which the search is being performed.
 * @param localeCode (optional) Identifies the locale (language/country) context for the search.
 * @param catalogCode Identifies the catalog in which the search is being performed.
 * @param filter (optional) The filter collection to apply to the search.
 * @param sort (optional) The sort collection to order the search results.
 * @param pageIndex (optional) The index of the page to retrieve.
 * @param pageSize (optional) The number of items per page.
 * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Searches_suggestionByKeyword(
  keyword: string,
  isAutocomplete: boolean | undefined,
  storeCode: string,
  localeCode: string | undefined,
  catalogCode: string,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.KeywordSearchSuggestionResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/searches/{keyword}/suggestion";

  url_ += buildEndpointQueryString({ sort, pageIndex, pageSize });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "IsAutocomplete=" + encodeURIComponent("" + isAutocomplete);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "StoreCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CatalogCode=" + encodeURIComponent("" + catalogCode);

  if (keyword === undefined || keyword === null) throw new Error("The parameter 'keyword' must be defined.");
  url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword));
  if (isAutocomplete === null) throw new Error("The parameter 'isAutocomplete' cannot be null.");
  if (storeCode === undefined || storeCode === null) throw new Error("The parameter 'storeCode' must be defined and cannot be null.");
  else if (localeCode === null) throw new Error("The parameter 'localeCode' cannot be null.");
  if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Searches_processSuggestionByKeyword(_response);
  });
}

function Searches_processSuggestionByKeyword(response: Response): Promise<MultifrontTypes.KeywordSearchSuggestionResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.KeywordSearchSuggestionResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (Indicates that the request contains invalid data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (Indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Hydrated Search Content List.
 * @param localeCode The locale ID, only numeric values allowed between 1 and 10. No special characters or alphanumeric values allowed.
 * @param catalogCode The catalog code.
 * @param storeCode (optional) The portal code.
 * @param isFacetList (optional) Indicates if the list is a facet list.
 * @param useSuggestion (optional) Indicates if suggestion is enabled.
 * @param isProductInheritanceEnabled (optional) Indicates if product inheritance is enabled.
 * @param expand (optional) A collection of properties to expand in the search results.
 * @param filter (optional) A collection of filters to apply when retrieving the Account Departments List.
 * @param sort (optional) Sorting determines whether the records are to be sorted in ascending or descending order.
 * @param pageIndex (optional) When the record count is high, utilizing pagination enables the retrieval of a specific range of records.
 * @param pageSize (optional) The number of items to be displayed per page in paginated within paginated results.
 * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
 */

export async function Searches_fullTextSearchBySearchKeyword(
  searchKeyword: string,
  localeCode: string,
  catalogCode: string,
  storeCode: string | undefined,
  isFacetList: boolean | undefined,
  useSuggestion: boolean | undefined,
  isProductInheritanceEnabled: boolean | undefined,
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined,
  refineBy: string | undefined,
  cacheInvalidator?: FilterTuple[] | undefined
): Promise<MultifrontTypes.FullTextSearchResponse> {
  let options_: RequestInit = {
    method: "GET",

    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/search/{searchKeyword}/full-text-search";

  url_ += buildEndpointQueryString({ expand, sort, pageIndex, pageSize, filter });

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "LocaleCode=" + encodeURIComponent("" + localeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "CatalogCode=" + encodeURIComponent("" + catalogCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "storeCode=" + encodeURIComponent("" + storeCode);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "IsFacetList=" + encodeURIComponent("" + isFacetList);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "UseSuggestion=" + encodeURIComponent("" + useSuggestion);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "RefineBy=" + encodeURIComponent("" + refineBy);

  url_ += (url_.indexOf("?") === -1 ? "?" : "&") + "IsProductInheritanceEnabled=" + encodeURIComponent("" + isProductInheritanceEnabled);

  if (searchKeyword === undefined || searchKeyword === null) throw new Error("The parameter 'searchKeyword' must be defined.");
  url_ = url_.replace("{searchKeyword}", encodeURIComponent("" + searchKeyword));
  if (localeCode === undefined || localeCode === null) throw new Error("The parameter 'localeCode' must be defined and cannot be null.");
  else if (catalogCode === undefined || catalogCode === null) throw new Error("The parameter 'catalogCode' must be defined and cannot be null.");
  else if (storeCode === null) throw new Error("The parameter 'storeCode' cannot be null.");
  if (isFacetList === null) throw new Error("The parameter 'isFacetList' cannot be null.");
  if (useSuggestion === null) throw new Error("The parameter 'useSuggestion' cannot be null.");
  if (isProductInheritanceEnabled === null) throw new Error("The parameter 'isProductInheritanceEnabled' cannot be null.");
  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return Searches_processFullTextSearchBySearchKeyword(_response);
  });
}

function Searches_processFullTextSearchBySearchKeyword(response: Response): Promise<MultifrontTypes.FullTextSearchResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.FullTextSearchResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException(
        "No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)",
        status,
        _responseText,
        _headers,
        result204
      );
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request (The request contain invalid Data.)", status, _responseText, _headers, result400);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found (This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

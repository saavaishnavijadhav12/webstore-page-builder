//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import * as Models from "./multifront-types";
import * as MultifrontTypes from "./multifront-types";

import { buildEndpointQueryString, getHeaders } from "./base";

import { FilterTuple } from "./multifront-types";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Hydrated Search Content List.
         * @param storeCode The identifier for the portal or store.
         * @param localeCode (optional) The identifier for the locale.
         * @param catalogCode The identifier for the catalog
         * @param profileId The identifier for the profile
         * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
         */
            
export async function SearchSettings_hydratedSearchGetByStoreCode(storeCode:string, localeCode:string | undefined, catalogCode:string, profileId:number): Promise<any> {
    

  let options_: RequestInit = {
    method: "GET",
   
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/search/hydrated-search/{storeCode}/{catalogCode}/{profileId}";

      


      
      
          
                      url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "localeCode=" + encodeURIComponent("" + localeCode);
          
      
  


  if (storeCode === undefined || storeCode === null)
      throw new Error("The parameter 'storeCode' must be defined.");
  url_ = url_.replace("{storeCode}", encodeURIComponent("" + storeCode));
  if (catalogCode === undefined || catalogCode === null)
      throw new Error("The parameter 'catalogCode' must be defined.");
  url_ = url_.replace("{catalogCode}", encodeURIComponent("" + catalogCode));
  if (profileId === undefined || profileId === null)
      throw new Error("The parameter 'profileId' must be defined.");
  url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
  if (localeCode === null)
      throw new Error("The parameter 'localeCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");


  return fetch(url_, options_).then((_response: Response) => {
     
          return SearchSettings_processHydratedSearchGetByStoreCode(_response);

  });
}


function SearchSettings_processHydratedSearchGetByStoreCode(response: Response): Promise<any> {
const status = response.status;
 let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
if (status === 200) {
  return response.text().then((_responseText) => {
  let result200: any = null;
  result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.HydratedSearchResponse;
  return result200;
  });
} else if (status === 204) {
  return response.text().then((_responseText) => {
  let result204: any = null;
  result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
  });
} else if (status === 400) {
  return response.text().then((_responseText) => {
  let result400: any = null;
  result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Bad Request (The request contain invalid Data.)", status, _responseText, _headers, result400);
  });
} else if (status === 500) {
  return response.text().then((_responseText) => {
  let result500: any = null;
  result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
  });
} else if (status === 404) {
  return response.text().then((_responseText) => {
  let result404: any = null;
  result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Not Found (This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
  });
} else if (status !== 200 && status !== 204) {
  return response.text().then((_responseText) => {
  return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  });
}
return Promise.resolve<any>(null as any);
 

}

 /**
         * Retrieves the hydrated search suggestion data.
         * @param searchTerm The search term or keyword entered by the user. Must be at least 3 characters long.
         * @param storeCode The identifier for the portal or store.
         * @param localeCode (optional) The identifier for the locale.
         * @param catalogCode The identifier for the catalog.
         * @param profileId The identifier for the profile.
         * @return Success (Indicates that the request is successfully executed and the response body contains the requested data.)
         */
            
 export async function SearchSettings_hydratedSearchGetBySearchTerm(searchTerm:string, storeCode:string, localeCode:string | undefined, catalogCode:string, profileId:number): Promise<any> {
    

  let options_: RequestInit = {
    method: "GET",
   
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/search/hydrated-search/{searchTerm}/{storeCode}/{catalogCode}/{profileId}";

      


      
      
          
                      url_ += (url_.indexOf('?') === -1 ? '?' : '&') + "localeCode=" + encodeURIComponent("" + localeCode);
          
      
  


  if (searchTerm === undefined || searchTerm === null)
      throw new Error("The parameter 'searchTerm' must be defined.");
  url_ = url_.replace("{searchTerm}", encodeURIComponent("" + searchTerm));
  if (storeCode === undefined || storeCode === null)
      throw new Error("The parameter 'storeCode' must be defined.");
  url_ = url_.replace("{storeCode}", encodeURIComponent("" + storeCode));
  if (catalogCode === undefined || catalogCode === null)
      throw new Error("The parameter 'catalogCode' must be defined.");
  url_ = url_.replace("{catalogCode}", encodeURIComponent("" + catalogCode));
  if (profileId === undefined || profileId === null)
      throw new Error("The parameter 'profileId' must be defined.");
  url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
  if (localeCode === null)
      throw new Error("The parameter 'localeCode' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");


  return fetch(url_, options_).then((_response: Response) => {
     
          return SearchSettings_processHydratedSearchGetBySearchTerm(_response);

  });
}


function SearchSettings_processHydratedSearchGetBySearchTerm(response: Response): Promise<any> {
const status = response.status;
 let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
if (status === 200) {
  return response.text().then((_responseText) => {
  let result200: any = null;
  result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.HydratedSearchResponse;
  return result200;
  });
} else if (status === 204) {
  return response.text().then((_responseText) => {
  let result204: any = null;
  result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("No Content (Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
  });
} else if (status === 400) {
  return response.text().then((_responseText) => {
  let result400: any = null;
  result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Bad Request (The request contain invalid Data.)", status, _responseText, _headers, result400);
  });
} else if (status === 500) {
  return response.text().then((_responseText) => {
  let result500: any = null;
  result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Server Error (Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
  });
} else if (status === 404) {
  return response.text().then((_responseText) => {
  let result404: any = null;
  result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ZnodeErrorDetail;
  return throwException("Not Found (This status code indicates that the server cannot find the requested resource.)", status, _responseText, _headers, result404);
  });
} else if (status !== 200 && status !== 204) {
  return response.text().then((_responseText) => {
  return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  });
}
return Promise.resolve<any>(null as any);
 

}


/**
 * Get the list of all store.
 * @param expand (optional)
 * @param filter (optional)
 * @param sort (optional)
 * @param pageIndex (optional)
 * @param pageSize (optional)
 * @return OK
 */

export async function SearchSettings_stores(
  expand: string[] | undefined,
  filter: FilterTuple[] | undefined,
  sort: { [key: string]: string } | undefined,
  pageIndex: number | undefined,
  pageSize: number | undefined
): Promise<MultifrontTypes.SearchFeatureSettingListResponse> {
  let options_: RequestInit = {
    method: "GET",
   
    headers: await getHeaders("GET", String(baseUrl)),
  };

  let url_ = baseUrl + "v2/search/feature-settings/stores";

  url_ += buildEndpointQueryString({ expand, filter, sort, pageIndex, pageSize });

  if (expand === null) throw new Error("The parameter 'expand' cannot be null.");
  if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
  if (sort === null) throw new Error("The parameter 'sort' cannot be null.");
  if (pageIndex === null) throw new Error("The parameter 'pageIndex' cannot be null.");
  if (pageSize === null) throw new Error("The parameter 'pageSize' cannot be null.");
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processStores(_response);
  });
}

function SearchSettings_processStores(response: Response): Promise<MultifrontTypes.SearchFeatureSettingListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchFeatureSettingListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Add search feature setting for given portal details.
 * @param body (optional)
 * @return OK
 */

export async function SearchSettings_add(body: Models.SearchFeatureSettingListRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/search/feature-settings/add";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "POST",
   
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processAdd(_response);
  });
}

function SearchSettings_processAdd(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Update search feature setting for given portal details.
 * @param body (optional) Search feature settings list.
 * @return OK
 */

export async function SearchSettings_change(body: Models.SearchFeatureSettingListRequest | undefined): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/search/feature-settings/change";

  url_ = url_.replace(/[?&]$/, "");

  const content_ = JSON.stringify(body);

  let options_: RequestInit = {
    body: content_,
    method: "PUT",
    headers: await getHeaders("PUT", String(baseUrl)),
    next: { revalidate: 0 },
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processChange(_response);
  });
}

function SearchSettings_processChange(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Delete search feature setting for given portal ID.
 * @param portalId Portal ID to be deleted.
 * @return OK
 */

export async function SearchSettings_featureSettingsDeleteByPortalId(portalId: number): Promise<MultifrontTypes.BooleanResponse> {
  let url_ = baseUrl + "v2/search/{portalId}/feature-settings";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "DELETE",
   
    headers: await getHeaders("DELETE", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processFeatureSettingsDeleteByPortalId(_response);
  });
}

function SearchSettings_processFeatureSettingsDeleteByPortalId(response: Response): Promise<MultifrontTypes.BooleanResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.BooleanResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Gets feature settings for giver portal.
 * @param portalId Portal id
 * @return OK
 */

export async function SearchSettings_featureSettingsGetByPortalId(portalId: number): Promise<MultifrontTypes.SearchFeatureSettingListResponse> {
  let options_: RequestInit = {
    method: "GET",
   
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/search/{portalId}/feature-settings";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processFeatureSettingsGetByPortalId(_response);
  });
}

function SearchSettings_processFeatureSettingsGetByPortalId(response: Response): Promise<MultifrontTypes.SearchFeatureSettingListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.SearchFeatureSettingListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Set portal score.
 * @param portalId Portal Id to set the score.
 * @param scoreType Score type.
 * @return OK
 */

export async function SearchSettings_portalScoresPost(portalId: number, scoreType: string): Promise<MultifrontTypes.PortalScoreResponse> {
  let url_ = baseUrl + "v2/search/{portalId}/portal-scores/{scoreType}";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (scoreType === undefined || scoreType === null) throw new Error("The parameter 'scoreType' must be defined.");
  url_ = url_.replace("{scoreType}", encodeURIComponent("" + scoreType));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
   
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processPortalScoresPost(_response);
  });
}

function SearchSettings_processPortalScoresPost(response: Response): Promise<MultifrontTypes.PortalScoreResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalScoreResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Set portal score.
 * @param portalId Portal Id to set the score.
 * @param scoreType Score type.
 * @return OK
 */

export async function SearchSettings_portalScoresAsync(portalId: number, scoreType: string): Promise<MultifrontTypes.PortalScoreResponse> {
  let url_ = baseUrl + "v2/search/{portalId}/portal-scores-async/{scoreType}";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (scoreType === undefined || scoreType === null) throw new Error("The parameter 'scoreType' must be defined.");
  url_ = url_.replace("{scoreType}", encodeURIComponent("" + scoreType));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
   
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processPortalScoresAsync(_response);
  });
}

function SearchSettings_processPortalScoresAsync(response: Response): Promise<MultifrontTypes.PortalScoreResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalScoreResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Set portal score using rabbit mq.
 * @param portalId Portal Id to set the score.
 * @param scoreType Score type.
 * @return OK
 */

export async function SearchSettings_enqueuePortalScoresAsync(portalId: number, scoreType: string): Promise<MultifrontTypes.PortalScoreResponse> {
  let url_ = baseUrl + "v2/search/{portalId}/enqueue-portal-scores-async/{scoreType}";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (scoreType === undefined || scoreType === null) throw new Error("The parameter 'scoreType' must be defined.");
  url_ = url_.replace("{scoreType}", encodeURIComponent("" + scoreType));
  url_ = url_.replace(/[?&]$/, "");

  let options_: RequestInit = {
    method: "POST",
   
    headers: await getHeaders("POST", String(baseUrl)),
  };

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processEnqueuePortalScoresAsync(_response);
  });
}

function SearchSettings_processEnqueuePortalScoresAsync(response: Response): Promise<MultifrontTypes.PortalScoreResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalScoreResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

/**
 * Get the portal score list for given score type.
 * @return OK
 */

export async function SearchSettings_portalScoresGetByPortalId(portalId: number, catalogId: number, scoreType: string): Promise<MultifrontTypes.PortalScoreListResponse> {
  let options_: RequestInit = {
    method: "GET",
   
    headers: await getHeaders("GET", String(baseUrl)),
    next: { revalidate: 0 },
  };

  let url_ = baseUrl + "v2/search/{portalId}/{catalogId}/portal-scores/{scoreType}";

  if (portalId === undefined || portalId === null) throw new Error("The parameter 'portalId' must be defined.");
  url_ = url_.replace("{portalId}", encodeURIComponent("" + portalId));
  if (catalogId === undefined || catalogId === null) throw new Error("The parameter 'catalogId' must be defined.");
  url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
  if (scoreType === undefined || scoreType === null) throw new Error("The parameter 'scoreType' must be defined.");
  url_ = url_.replace("{scoreType}", encodeURIComponent("" + scoreType));
  url_ = url_.replace(/[?&]$/, "");

  return fetch(url_, options_).then((_response: Response) => {
    return SearchSettings_processPortalScoresGetByPortalId(_response);
  });
}

function SearchSettings_processPortalScoresGetByPortalId(response: Response): Promise<MultifrontTypes.PortalScoreListResponse> {
  const status = response.status;
  let _headers: any = {};
  if (response.headers && response.headers.forEach) {
    response.headers.forEach((v: any, k: any) => (_headers[k] = v));
  }
  if (status === 200) {
    return response.text().then((_responseText) => {
      let result200: any = null;
      result200 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.PortalScoreListResponse);
      return result200;
    });
  } else if (status === 204) {
    return response.text().then((_responseText) => {
      let result204: any = null;
      result204 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("No Content", status, _responseText, _headers, result204);
    });
  } else if (status === 400) {
    return response.text().then((_responseText) => {
      let result400: any = null;
      result400 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Bad Request", status, _responseText, _headers, result400);
    });
  } else if (status === 500) {
    return response.text().then((_responseText) => {
      let result500: any = null;
      result500 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Internal Server Error", status, _responseText, _headers, result500);
    });
  } else if (status === 404) {
    return response.text().then((_responseText) => {
      let result404: any = null;
      result404 = _responseText === "" ? null : (JSON.parse(_responseText) as Models.ZnodeErrorDetail);
      return throwException("Not Found", status, _responseText, _headers, result404);
    });
  } else if (status !== 200 && status !== 204) {
    return response.text().then((_responseText) => {
      return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    });
  }
  return Promise.resolve<any>(null as any);
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): any {
  try {
    if (result !== null && result !== undefined) throw result;
    else throw new Error(message);
  } catch (ex) {
    const parsedRes = response === "" ? null : (JSON.parse(response) as any);
    return parsedRes;
  }
}

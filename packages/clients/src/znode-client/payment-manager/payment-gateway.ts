//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
import * as Models from "../../types/payment-manager-interface";
import { getHeaders } from "../V1/base";

const baseUrl = process.env.API_URL;

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Retrieves the gateway token using the plugin identifier.
         * @param pluginIdentifier The unique identifier for the plugin.
         * @return Success(Indicates that the request is successfully executed and the response body returns the data in the PaymentManagerTokenResponse model.)
         */
            
export async function PaymentGateway_token(pluginIdentifier:string ): Promise<Models.PaymentManagerTokenResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/token";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentGateway_processToken(_response);
     
        });
    }
   
   
  function PaymentGateway_processToken(response: Response): Promise<Models.PaymentManagerTokenResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerTokenResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Retrieve the gateway token using the plugin identifier and customer id.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param customerId The unique identifier for the customer.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerTokenResponse model.)
         */
            
export async function PaymentGateway_tokenByCustomerId(pluginIdentifier:string, customerId:string ): Promise<Models.PaymentManagerTokenResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/token/{customerId}";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentGateway_processTokenByCustomerId(_response);
     
        });
    }
   
   
  function PaymentGateway_processTokenByCustomerId(response: Response): Promise<Models.PaymentManagerTokenResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerTokenResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Capture payment operation.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param body (optional) The model containing the payment information for the pay now.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerCaptureResponse model.)
         */
    
        export async function PaymentGateway_capture(pluginIdentifier:string, body:Models.PaymentManagerCaptureRequest | undefined): Promise<Models.PaymentManagerCaptureResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/capture";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processCapture(_response);
        });
    }
   
   function PaymentGateway_processCapture(response: Response): Promise<Models.PaymentManagerCaptureResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerCaptureResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Submitted the payment in case of authorize.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param body (optional) The model containing the payment information for the pay now.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerAuthorizeResponse model.)
         */
    
        export async function PaymentGateway_authorize(pluginIdentifier:string, body:Models.PaymentManagerAuthorizeRequest | undefined): Promise<Models.PaymentManagerAuthorizeResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/authorize";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processAuthorize(_response);
        });
    }
   
   function PaymentGateway_processAuthorize(response: Response): Promise<Models.PaymentManagerAuthorizeResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerAuthorizeResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Refund operation.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param body (optional) The model containing the payment information required for the refund of the payment.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerRefundResponse model.)
         */
    
        export async function PaymentGateway_refund(pluginIdentifier:string, body:Models.PaymentManagerRefundRequest | undefined): Promise<Models.PaymentManagerRefundResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/refund";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processRefund(_response);
        });
    }
   
   function PaymentGateway_processRefund(response: Response): Promise<Models.PaymentManagerRefundResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerRefundResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Void transaction operation.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param body (optional) The model containing the payment information required to void the payment.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerVoidResponse model.)
         */
    
        export async function PaymentGateway_void(pluginIdentifier:string, body:Models.PaymentManagerVoidRequest | undefined): Promise<Models.PaymentManagerVoidResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/void";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processVoid(_response);
        });
    }
   
   function PaymentGateway_processVoid(response: Response): Promise<Models.PaymentManagerVoidResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerVoidResponse;
        return result200;
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Retrieve the payment transaction details.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param transactionId Transaction Id of the payment.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerTransactionDetailsResponse model.)
         */
            
export async function PaymentGateway_transactionStatusDetails(pluginIdentifier:string, transactionId:string ): Promise<Models.PaymentManagerTransactionDetailsResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/transaction-status-details/{transactionId}";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentGateway_processTransactionStatusDetails(_response);
     
        });
    }
   
   
  function PaymentGateway_processTransactionStatusDetails(response: Response): Promise<Models.PaymentManagerTransactionDetailsResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerTransactionDetailsResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Creates payment method token using bank account and routing number.
         * @param pluginIdentifier The unique identifier for the plugin configuration set.
         * @param body The model contains the bank account information required to create payment method.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerBankAccountResponse model.)
         */
    
        export async function PaymentGateway_bankAccount(pluginIdentifier:string, body:Models.PaymentManagerBankAccountRequest): Promise<Models.PaymentManagerBankAccountResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/bank-account";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processBankAccount(_response);
        });
    }
   
   function PaymentGateway_processBankAccount(response: Response): Promise<Models.PaymentManagerBankAccountResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerBankAccountResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Processes a direct payment for the purchase without prior authorization.
         * @param pluginIdentifier The unique identifier for the plugin configuration sets.
         * @param body (optional) The model containing the payment information for creating transaction.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerPurchaseResponse model.)
         */
    
        export async function PaymentGateway_purchase(pluginIdentifier:string, body:Models.PaymentManagerPurchaseRequest | undefined): Promise<Models.PaymentManagerPurchaseResponse> {

        let url_ = baseUrl + "v1/plugin/{pluginIdentifier}/purchase";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentGateway_processPurchase(_response);
        });
    }
   
   function PaymentGateway_processPurchase(response: Response): Promise<Models.PaymentManagerPurchaseResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerPurchaseResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers, result500);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
//TODO: Payment - need to create separate baseclient for payment manager and utilize that here for importing getHeaders.
import { getHeaders } from "../V1/base";
import * as Models from "../../types/payment-manager-interface";

const baseUrl = process.env.API_URL;


/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

/**
         * Retrieve a configuration sets using the Plugin Identifier.
         * @param pluginIdentifier The unique identifier of the configuration set.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in ConfigurationSetResponse model.)
         */
            
export async function PaymentBusiness_configurationSet(pluginIdentifier:string ): Promise<Models.ConfigurationSetResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/configuration-set/{pluginIdentifier}";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentBusiness_processConfigurationSet(_response);
     
        });
    }
   
   
  function PaymentBusiness_processConfigurationSet(response: Response): Promise<Models.ConfigurationSetResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ConfigurationSetResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Create a customer information.
         * @param body (optional) model with customer information.
         * @return OK
         */
    
        export async function PaymentBusiness_paymentCustomer(body:Models.PaymentManagerCustomerRequest | undefined): Promise<Models.ConfigurationSetResponse> {

        let url_ = baseUrl + "v1/payment-customer";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentBusiness_processPaymentCustomer(_response);
        });
    }
   
   function PaymentBusiness_processPaymentCustomer(response: Response): Promise<Models.ConfigurationSetResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ConfigurationSetResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        return throwException("Created(Indicates that the request is successfully executed and the response body return the data in PaymentManagerServiceCustomerResponse model.)", status, _responseText, _headers);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Create a transaction information.
         * @param body (optional) model with transaction information.
         * @return OK
         */
    
        export async function PaymentBusiness_paymentTransaction(body:Models.PaymentManagerTransactionRequest | undefined): Promise<Models.ConfigurationSetResponse> {

        let url_ = baseUrl + "v1/payment-transaction";

        url_ = url_.replace(/[?&]$/, "");

     const content_ = JSON.stringify(body);

         let options_: RequestInit = {
            body: content_,
            method: "POST",
            cache: "no-store",
            headers: await getHeaders("POST", String(baseUrl)),
        };

        return fetch(url_, options_).then((_response: Response) => {
   
            return PaymentBusiness_processPaymentTransaction(_response);
        });
    }
   
   function PaymentBusiness_processPaymentTransaction(response: Response): Promise<Models.ConfigurationSetResponse> {
       const status = response.status;
       let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ConfigurationSetResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status === 201) {
        return response.text().then((_responseText) => {
        return throwException("Created(Indicates that the request is successfully executed and the response body return the data in PaymentManagerServiceTransactionResponse model.)", status, _responseText, _headers);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
  
    }

    
    
    
        
    
    
    /**
         * Retrieves the transaction details based on the provided plugin identifier and transaction ID.
         * @param pluginIdentifier The unique identifier for the plugin.
         * @param transactionId The unique identifier for the transaction.
         * @return OK
         */
            
export async function PaymentBusiness_transaction(pluginIdentifier:string, transactionId:string ): Promise<Models.ConfigurationSetResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/transaction/{pluginIdentifier}/{transactionId}";

        if (pluginIdentifier === undefined || pluginIdentifier === null)
            throw new Error("The parameter 'pluginIdentifier' must be defined.");
        url_ = url_.replace("{pluginIdentifier}", encodeURIComponent("" + pluginIdentifier));
        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentBusiness_processTransaction(_response);
     
        });
    }
   
   
  function PaymentBusiness_processTransaction(response: Response): Promise<Models.ConfigurationSetResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ConfigurationSetResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

    
    
    
        
    
    
    /**
         * Retrieve Refund transaction Id.
         * @param transactionId transaction id.
         * @return Success(Indicates that the request is successfully executed and the response body return the data in PaymentManagerRefundTransactionResponse model.)
         */
            
export async function PaymentBusiness_refundTransaction(transactionId:string ): Promise<Models.PaymentManagerRefundTransactionResponse> {
 

        let options_: RequestInit = {
          method: "GET",
          cache: "no-store",
          headers: await getHeaders("GET", String(baseUrl)),
          next: { revalidate: 0 }
        };

        let url_ = baseUrl + "v1/refund-transaction/{transactionId}";

        if (transactionId === undefined || transactionId === null)
            throw new Error("The parameter 'transactionId' must be defined.");
        url_ = url_.replace("{transactionId}", encodeURIComponent("" + transactionId));
        url_ = url_.replace(/[?&]$/, "");

 
        return fetch(url_, options_).then((_response: Response) => {
           
           return PaymentBusiness_processRefundTransaction(_response);
     
        });
    }
   
   
  function PaymentBusiness_processRefundTransaction(response: Response): Promise<Models.PaymentManagerRefundTransactionResponse> {
      const status = response.status;
      let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
        return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText) as Models.PaymentManagerRefundTransactionResponse;
        return result200;
        });
    } else if (status === 204) {
        return response.text().then((_responseText) => {
        let result204: any = null;
        result204 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("No Content(Indicates that the request is successfully executed, but the response body does not contain any data.)", status, _responseText, _headers, result204);
        });
    } else if (status === 400) {
        return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Bad Request(The request contain invalid Data.)", status, _responseText, _headers, result400);
        });
    } else if (status === 404) {
        return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText) as Models.ErrorDetails;
        return throwException("Not Found", status, _responseText, _headers, result404);
        });
    } else if (status === 500) {
        return response.text().then((_responseText) => {
        return throwException("Server Error(Indicates that an error occurred on the server.)", status, _responseText, _headers);
        });
    } else if (status !== 200 && status !== 204) {
        return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        });
    }
    return Promise.resolve<any>(null as any);
      
      
    }

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
try{
    if (result !== null && result !== undefined)
        throw result;
   
    else
        throw new Error(message);
   }
   catch(ex)
   {
    const parsedRes = response === "" ? null : JSON.parse(response) as any;
    return parsedRes;
   }
}